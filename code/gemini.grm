structure A = Absyn
structure S = GeminiString(String)
structure BA = GeminiBitArray(Vector)

fun extractTypeDec (A.TypeDec list) = SOME(list)
  | extractTypeDec _ = NONE

fun extractFunDec (A.FunctionDec list) = SOME(list)
  | extractFunDec _ = NONE

fun param [] = A.NoParam
  | param [f] = A.SingleParam(f)
  | param fields = A.MultiParams(fields)

fun numberedFields lst = foldl (fn((expr, posn), (idx, acc)) => (idx + 1, (Symbol.symbol(Int.toString(idx)), expr, posn))::acc) (1, []) lst

fun extractFields (A.RecordExp{fields, pos}) = SOME(fields)
  | _ = NONE

%%
%term
    EOF
  | DATATYPE | TYPE | VAL | REF | FUN | MODULE | STRUCTURE | STRUCT | SIGNATURE | SIG | LIST | SW
  | LET | IN | END | IF | THEN | ELSE
  | ORELSE | ANDALSO | NOT
  | NIL | WITH | OF | OP | CASE
  | PIPE_EQUALS | FAT_ARROW | THIN_ARROW
  | BIT_NOT | BIT_OR | BIT_AND | BIT_XOR | BIT_SLL | BIT_SRL | BIT_SRA
  | GE | GT | LE | LT | NEQ | EQ
  | UMINUS | INT_DIVIDE | INT_TIMES | INT_PLUS | INT_MINUS | INT_MOD | REAL_DIVIDE | REAL_TIMES | REAL_PLUS | REAL_MINUS
  | RBRACE | LBRACE | RBRACK | LBRACK | RPAREN | LPAREN
  | DOT | SEMICOLON | COLON | COMMA | POUND | AT | ASSIGN | BANG | CONS | POUND_TIMES | AND
  | ID of string | TID of string | INT of int | STRING of string | REAL of real | BIT of GeminiBit.bit
  | APPLY

%nonterm
      program of A.exp
        | structs_or_sigs of A.exp
            | structures of A.structsig list
                | structure_nt of A.structsig
                    | struct_body of A.dec list
            | signatures of A.structsig list
                | signature_nt of A.structsig
                    | sig_body of A.def list
                    | sigs of A.def list
                        | val_sig of A.def
                        | ty_sig of A.def
                        | dataty_sig of A.def
                        | module_sig of A.def
                        | non_ty_sigs of A.def list
                        | non_dataty_sigs of A.def list
                        | non_module_sigs of A.def list
        | exp of A.exp
            | access of A.exp
                | array_access of A.exp
                | struct_access of A.exp
                | tuple_access of A.exp
                | record_access of A.exp
                | deref of A.exp
            | operation of A.exp
                | int_op of A.exp
                | real_op of A.exp
                | bit_op of A.exp
                | compare_op of A.exp
                | list_op of A.exp
            | let_block of A.exp
                | let_body of A.exp
                    | semicolon_exp0 of (A.exp * int) list
                | decs of A.dec list
                    | val_dec of A.dec
                    | fun_dec of A.dec
                        | fun_dec_no_type of A.dec
                        | fun_dec_with_type of A.dec
                        | fun_params of A.param list
                            | fun_param of A.param
                    | ty_dec of A.dec
                        | ty of A.ty
                            | no_ty_fields of A.field list
                            | ty_fields of A.field list
                            | ty_field_tail of A.field list
                        | with_type of A.opdef list
                            | with_type_tail of A.opdef list
                    | dataty_dec of A.dec
                        | dataty_tail
                    | module_dec of A.dec
                        | module_dec_no_type of A.dec
                        | module_dec_with_type of A.dec
                    | non_fun_dec of A.dec list
                    | non_ty_dec of A.dec list
                    | non_dataty_dec of A.dec list
                    | non_module_dec of A.dec list
            | exp_seq of A.exp
            | assign of A.exp
            | conditional of A.exp
            | insts of A.exp
                | rec_inst of A.exp
                    | rec_inst_body of (Symbol.symbol * A.exp * int) list
                    | rec_field_comma_tail of (Symbol.symbol * A.exp * int) list
                | ref_inst of A.exp
                | array_inst of A.exp
                    | bit_array_inst
                | list_inst of A.exp
                    | list_elements of (A.exp * int) list
                | sw_tuple_inst of A.exp
                | hw_tuple_inst of A.exp
                | exp_comma_tail of (A.exp * int) list
            | with_value of A.exp
            | pattern_match of A.exp
                | matches of A.case' list
                | matches_tail of A.case' list
        | epsilon

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Gemini

%keyword DATATYPE TYPE VAL REF FUN MODULE STRUCTURE STRUCT SIGNATURE SIG
  LET IN END IF THEN ELSE
  ORELSE ANDALSO NOT
  NIL WITH OF OP

%prefer THEN ELSE LPAREN

%value ID ("foo")
%value INT (1)
%value STRING ("")
%value BIT (GeminiBit.fromInt(0))
%value REAL (1.0)

%change -> IN ID END
      | EQ -> ASSIGN
      | ASSIGN -> EQ
      | SEMICOLON ELSE -> ELSE
      | LET ID EQ -> LET TYPE ID EQ
      | LET ID ASSIGN -> LET VAL ID ASSIGN
      | LET ID COLON ID ASSIGN -> LET VAL ID COLON ID ASSIGN
      | LET ID LPAREN -> LET FUN ID LPAREN
      | COMMA -> SEMICOLON
      | SEMICOLON -> COMMA
      | SEMICOLON -> COLON
      | COLON -> SEMICOLON
      | SEMICOLON THEN -> THEN
      | SEMICOLON VAL -> VAL
      | SEMICOLON TYPE -> TYPE
      | SEMICOLON FUN -> FUN
      | SEMICOLON DATATYPE -> DATATYPE
      | SEMICOLON MODULE -> MODULE
      | SEMICOLON END -> END
      | SEMICOLON IN -> IN

%nonassoc INT STRING REAL BIT ID TID
%nonassoc OF
%nonassoc THEN
%nonassoc ELSE
%nonassoc LBRACK RBRACK
%right ASSIGN
%right WITH
%left LBRACE RBRACE
%left CONS
%left ORELSE
%left ANDALSO
%left BIT_SLL BIT_SRA BIT_SRL
%nonassoc EQ NEQ GT LT GE LE
%left REAL_MINUS REAL_PLUS INT_MINUS INT_PLUS BIT_XOR BIT_OR POUND_TIMES
%left REAL_DIVIDE REAL_TIMES INT_DIVIDE INT_TIMES BIT_AND INT_MOD
%left LIST SW REF
%left UMINUS BIT_NOT
%left LPAREN RPAREN APPLY

%%

program	      : structs_or_sigs                                             (structs_or_sigs)
              | exp                                                         (exp)

exp           : exp exp %prec APPLY                                         ()
              | INT                                                         (A.IntExp(INT, INTleft))
              | STRING                                                      (A.StringExp(STRING, STRINGleft))
              | REAL                                                        (A.RealExp(REAL, REALleft))
              | BIT                                                         (A.BitExp(BIT, BITleft))
              | ID                                                          (A.VarExp(Symbol.symbol(ID), IDleft))
              | access                                                      (access)
              | operation                                                   (operation)
              | let_block                                                   (let_block)
              | assign                                                      (assign)
              | exp_seq                                                     (exp_seq)
              | conditional                                                 (conditional)
              | insts                                                       (insts)
              | with_value                                                  (with_value)
              | pattern_match                                               (pattern_match)
              | LPAREN RPAREN                                               (A.SeqExp[])

structs_or_sigs
              : structures structs_or_sigs                                  ()
              | signatures structs_or_sigs                                  ()
              | epsilon                                                     ()

structures    : structure_nt structures                                     ()
              | structure_nt                                                ()

structure_nt  : STRUCTURE ID EQ struct_body                                 ()
              | STRUCTURE ID COLON ID EQ struct_body                        ()
              | STRUCTURE ID COLON sig_body EQ struct_body                  ()

struct_body   : STRUCT decs END                                             ()

signatures    : signature_nt signatures                                     ()
              | signature_nt                                                ()

signature_nt  : SIGNATURE ID EQ sig_body                                    ()

sig_body      : SIG sigs END                                                ()

sigs          : val_sig sigs                                                ()
              | ty_sig non_ty_sigs                                          ()
              | module_sig non_module_sigs                                  ()
              | dataty_sig non_dataty_sigs                                  ()
              | epsilon                                                     ()

non_ty_sigs   : val_sig sigs                                                ()
              | module_sig non_module_sigs                                  ()
              | dataty_sig non_dataty_sigs                                  ()
              | epsilon                                                     ()

non_module_sigs
              : val_sig sigs                                                ()
              | ty_sig non_ty_sigs                                          ()
              | dataty_sig non_dataty_sigs                                  ()
              | epsilon                                                     ()

non_dataty_sigs
              : val_sig sigs                                                ()
              | ty_sig non_ty_sigs                                          ()
              | module_sig non_module_sigs                                  ()
              | epsilon                                                     ()

val_sig       : VAL ID COLON ty                                             ()

ty_sig        : TYPE ID EQ ty                                               ()
              | TYPE ID EQ ty ty_sig                                        ()
              | TYPE ID                                                     ()
              | TYPE ID ty_sig                                              ()

module_sig    : MODULE ID COLON ty THIN_ARROW  ty                           ()
              | MODULE ID COLON ty THIN_ARROW ty module_sig                 ()

dataty_sig    : dataty_dec                                                  ()
              | dataty_dec dataty_sig                                       ()
              | DATATYPE ID                                                 ()
              | DATATYPE ID dataty_sig                                      ()

array_access  : exp LBRACK exp RBRACK                                       (A.ArrayAccExp{exp = exp1, index = exp2, pos = exp1left})

struct_access : ID DOT ID                                                   (A.StructAccExp{name = Symbol.symbol(ID1), field = Symbol.symbol(ID2), pos = ID1left}

tuple_access  : POUND INT exp                                               (A.RecordAccExp{exp = exp, field = Symbol.symbol(Int.toString(INT)), POUNDleft})

record_access : POUND ID exp                                                (A.RecordAccExp{exp = exp, field = Symbol.symbol(ID), POUNDleft})

deref         : BANG exp                                                    (A.DerefExp{exp = exp, pos = BANGleft})

access        : array_access                                                (array_access)
              | struct_access                                               (struct_access)
              | tuple_access                                                (tuple_access)
              | record_access                                               (record_access)
              | deref                                                       (deref)

operation     : int_op                                                      (int_op)
              | real_op                                                     (real_op)
              | bit_op                                                      (bit_op)
              | compare_op                                                  (compare_op)
              | list_op                                                     (list_op)

int_op        : UMINUS exp                                                  (A.NegExp{exp = exp1, pos = UMINUSleft})
              | exp INT_PLUS exp                                            (A.OpExp{left = exp1, oper = A.IntPlusOp, right = exp2, pos = exp1left})
              | exp INT_MINUS exp                                           (A.OpExp{left = exp1, oper = A.IntMinusOp, right = exp2, pos = exp1left})
              | exp INT_TIMES exp                                           (A.OpExp{left = exp1, oper = A.IntTimesOp, right = exp2, pos = exp1left})
              | exp INT_DIVIDE exp                                          (A.OpExp{left = exp1, oper = A.IntDivideOp, right = exp2, pos = exp1left})
              | exp INT_MOD exp                                             (A.OpExp{left = exp1, oper = A.IntModOp, right = exp2, pos = exp1left})

real_op       : exp REAL_PLUS exp                                           (A.OpExp{left = exp1, oper = A.RealPlusOp, right = exp2, pos = exp1left})
              | exp REAL_MINUS exp                                          (A.OpExp{left = exp1, oper = A.RealMinusOp, right = exp2, pos = exp1left})
              | exp REAL_TIMES exp                                          (A.OpExp{left = exp1, oper = A.RealTimesOp, right = exp2, pos = exp1left})
              | exp REAL_DIVIDE exp                                         (A.OpExp{left = exp1, oper = A.RealDivideOp, right = exp2, pos = exp1left})

bit_op        : exp BIT_NOT                                                 (A.NegExp{exp = exp1, pos = exp1left})
              | exp BIT_OR exp                                              (A.OpExp{left = exp1, oper = A.BitOrOp, right = exp2, pos = exp1left})
              | exp BIT_AND exp                                             (A.OpExp{left = exp1, oper = A.BitAndOp, right = exp2, pos = exp1left})
              | exp BIT_XOR exp                                             (A.OpExp{left = exp1, oper = A.BitXorOp, right = exp2, pos = exp1left})
              | exp BIT_SLL exp                                             (A.OpExp{left = exp1, oper = A.BitSLLOp, right = exp2, pos = exp1left})
              | exp BIT_SRL exp                                             (A.OpExp{left = exp1, oper = A.BitSRLOp, right = exp2, pos = exp1left})
              | exp BIT_SRA exp                                             (A.OpExp{left = exp1, oper = A.BitSRAOp, right = exp2, pos = exp1left})

compare_op    : exp EQ exp                                                  (A.OpExp{left = exp1, oper = A.EqOp, right = exp2, pos = exp1left})
              | exp NEQ exp                                                 (A.OpExp{left = exp1, oper = A.NeqOp, right = exp2, pos = exp1left})
              | exp GT exp                                                  (A.OpExp{left = exp1, oper = A.GtOp, right = exp2, pos = exp1left})
              | exp LT exp                                                  (A.OpExp{left = exp1, oper = A.LtOp, right = exp2, pos = exp1left})
              | exp GE exp                                                  (A.OpExp{left = exp1, oper = A.GeOp, right = exp2, pos = exp1left})
              | exp LE exp                                                  (A.OpExp{left = exp1, oper = A.LeOp, right = exp2, pos = exp1left})

list_op       : exp CONS exp                                                (A.OpExp{left = exp1, oper = A.ConsOp, right = exp2, pos = exp1left})

let_block     : LET decs IN exp END                                         (A.LetExp{decs = decs, body = exp1, pos = LETleft})

decs          : val_dec decs                                                ()
              | fun_dec non_fun_dec                                         ()
              | ty_dec non_ty_dec                                           ()
              | dataty_dec non_dataty_dec                                   ()
              | module_dec non_module_dec                                   ()
              | epsilon                                                     ()

non_fun_dec   : val_dec decs                                                ()
              | ty_dec non_ty_dec                                           ()
              | dataty_dec non_dataty_dec                                   ()
              | module_dec non_module_dec                                   ()
              | epsilon                                                     ()

non_ty_dec    : val_dec decs                                                ()
              | fun_dec non_fun_dec                                         ()
              | dataty_dec non_dataty_dec                                   ()
              | module_dec non_module_dec                                   ()
              | epsilon                                                     ()

non_dataty_dec: val_dec decs                                                ()
              | ty_dec non_ty_dec                                           ()
              | fun_dec non_fun_dec                                         ()
              | module_dec non_module_dec                                   ()
              | epsilon                                                     ()

non_module_dec: val_dec decs                                                ()
              | fun_dec non_fun_dec                                         ()
              | ty_dec non_ty_dec                                           ()
              | dataty_dec non_dataty_dec                                   ()
              | epsilon                                                     ()

val_dec       : VAL ID EQ exp                                               (A.ValDec{name = Symbol.symbol(ID), escape = ref true, ty = NONE, init = exp1, pos = VALleft})
              | VAL ID COLON ty EQ exp                                      (A.ValDec{name = Symbol.symbol(ID), escape = ref true, ty = SOME(ty, tyleft), init = exp1, pos = VALleft})

fun_dec       : fun_dec_no_type                                             (fun_dec_no_type)
              | fun_dec_with_type                                           (fun_dec_with_type)
              | fun_dec_no_type fun_dec                                     (A.FunctionDec(valOf(extractFunDec(fun_dec_no_type)) @ valOf(extractFunDec(fun_dec))))
              | fun_dec_with_type fun_dec                                   (A.FunctionDec(valOf(extractFunDec(fun_dec_with_type)) @ valOf(extractFunDec(fun_dec))))

fun_dec_no_type
              : FUN ID fun_params EQ exp                                    (A.FunctionDec[{name = Symbol.symbol(ID), params = fun_params1, result = NONE, body = exp1, pos = FUNleft}])

fun_dec_with_type
              : FUN ID fun_params COLON ty EQ exp                           (A.FunctionDec[{name = Symbol.symbol(ID), params = fun_params1, result = SOME(ty1), body = exp1, pos = FUNleft}])

fun_params    : fun_params fun_param                                        (fun_params1 @ [fun_param1])
              | fun_param                                                   ([fun_param1])

fun_param     : ID                                                          (A.SingleParam{name = Symbol.symbol(ID), ty = NONE, escape = ref true, pos = IDleft})
              | LPAREN no_ty_fields RPAREN                                  (param(no_ty_fields))
              | LPAREN ty_fields RPAREN                                     (param(ty_fields))

ty_dec        : TYPE ID EQ ty                                               (A.TypeDec[{name = Symbol.symbol(ID), ty = ty1, opdef = NONE, pos = TYPEleft}])
              | TYPE ID EQ ty ty_dec                                        (A.TypeDec([{name = Symbol.symbol(ID), ty = ty1, opdef = NONE, pos = TYPEleft}] @ valOf(extractTypeDec(ty_dec))))
              | TYPE ID EQ ty with_type                                     (A.TypeDec[{name = Symbol.symbol(ID), ty = ty1, opdef = SOME(with_type), pos = TYPEleft}])
              | TYPE ID EQ ty with_type ty_dec                              (A.TypeDec([{name = Symbol.symbol(ID), ty = ty1, opdef = SOME(with_type), pos = TYPEleft}] @ valOf(extractTypeDec(ty_dec))))

ty            : TID                                                         (A.GenericTy(Symbol.symbol(TID), TIDleft))
              | ID                                                          (A.NameTy(Symbol.symbol(ID), IDleft))
              | ty INT_TIMES ty                                             (A.SWTupleTy(ty1, ty2, ty1left))
              | ty POUND_TIMES ty                                           (A.HWTupleTy(ty1, ty2, ty1left))
              | LBRACE ty_fields RBRACE                                     (A.RecordTy(ty_fields, LBRACEleft))
              | ty AT exp                                                   (A.TemporalTy(ty1, exp1, ty1left))
              | ty LBRACK exp RBRACK                                        (A.ArrayTy(ty1, exp1, ty1left))
              | ty LIST                                                     (A.ListTy(ty1, ty1left))
              | ty REF                                                      (A.RefTy(ty1, ty1left))
              | ty SW                                                       (A.SWTy(ty1, ty1left))

no_ty_fields  : ID                                                          ([{name = Symbol.symbol(ID), ty = NONE, escape = ref true, pos = IDleft}])
              | no_ty_fields COMMA ID                                       (no_ty_fields1 @ [{name = Symbol.symbol(ID), ty = NONE, escape = ref true, pos = no_ty_fields1left}])

ty_fields     : ty_field_tail                                               (ty_field_tail)
              | epsilon                                                     ([])

ty_field_tail : ID COLON ty                                                 ([{name = Symbol.symbol(ID), ty = SOME(ty1), escape = ref true, pos = IDleft}])
              | ty_field_tail COMMA ID COLON ty                             (ty_field_tail1 @ [{name = Symbol.symbol(ID), ty = SOME(ty1), escape = ref true, pos = ty_field_tail1left}])

with_type     : WITH OP EQ LPAREN ID COMMA ID RPAREN EQ exp with_type_tail  ([{oper = A.EqOp, param_a = Symbol.symbol(ID1), param_b = Symbol.symbol(ID2), body = exp1, pos = WITHleft}] @ with_type_tail1)
              | WITH OP NEQ LPAREN ID COMMA ID RPAREN EQ exp with_type_tail ([{oper = A.NeqOp, param_a = Symbol.symbol(ID1), param_b = Symbol.symbol(ID2), body = exp1, pos = WITHleft}] @ with_type_tail1)
              | WITH OP GT LPAREN ID COMMA ID RPAREN EQ exp with_type_tail  ([{oper = A.GtOp, param_a = Symbol.symbol(ID1), param_b = Symbol.symbol(ID2), body = exp1, pos = WITHleft}] @ with_type_tail1)
              | WITH OP LT LPAREN ID COMMA ID RPAREN EQ exp with_type_tail  ([{oper = A.LtOp, param_a = Symbol.symbol(ID1), param_b = Symbol.symbol(ID2), body = exp1, pos = WITHleft}] @ with_type_tail1)
              | WITH OP GE LPAREN ID COMMA ID RPAREN EQ exp with_type_tail  ([{oper = A.GeOp, param_a = Symbol.symbol(ID1), param_b = Symbol.symbol(ID2), body = exp1, pos = WITHleft}] @ with_type_tail1)
              | WITH OP LE LPAREN ID COMMA ID RPAREN EQ exp with_type_tail  ([{oper = A.LeOp, param_a = Symbol.symbol(ID1), param_b = Symbol.symbol(ID2), body = exp1, pos = WITHleft}] @ with_type_tail1)

with_type_tail: AND with_type                                               (with_type)
              | epsilon                                                     ([])

dataty_dec    : DATATYPE ID EQ ID OF ty dataty_tail                         ()

dataty_tail   : PIPE_EQUALS ID OF ty dataty_tail                            ()
              | epsilon                                                     ()

module_dec    : module_dec_no_type                                          ()
              | module_dec_with_type                                        ()

module_dec_no_type
              : MODULE ID fun_param EQ exp                                  ()

module_dec_with_type
              : MODULE ID fun_param COLON ty EQ exp                         ()

semicolon_exp0: SEMICOLON exp semicolon_exp0                                ([(exp1, exp1left)] @ semicolon_exp0)
              | epsilon                                                     ([])

exp_seq       : LPAREN exp RPAREN                                           (A.SeqExp([(exp1, exp1left)]))
              | LPAREN exp SEMICOLON exp semicolon_exp0 RPAREN              (A.SeqExp([(exp1, exp1left)] @ [(exp2, exp2left)] @ semicolon_exp0))

assign        : exp ASSIGN exp                                              (A.AssignExp{lhs = exp1, rhs = exp2, pos = exp1left})

exp_comma_tail: COMMA exp exp_comma_tail                                    ([(exp1, exp1left)] @ exp_comma_tail)
              | epsilon                                                     ([])

conditional   : IF exp THEN exp ELSE exp                                    (A.IfExp{test = exp1, then' = exp2, else' = SOME(exp3), pos = IFleft})
              | IF exp THEN exp                                             (A.IfExp{test = exp1, then' = exp2, else' = NONE, pos = IFleft})
              | exp ANDALSO exp                                             (A.IfExp{test = exp1, then' = exp2, else' = SOME(A.IntExp(0)), pos = exp1left})
              | exp ORELSE exp                                              (A.IfExp{test = exp1, then' = A.IntExp(1), else' = SOME(exp2), pos = exp1left})

insts         : rec_inst                                                    (rec_inst)
              | ref_inst                                                    (ref_inst)
              | array_inst                                                  (array_inst)
              | list_inst                                                   (list_inst)
              | sw_tuple_inst                                               (sw_tuple_inst)
              | hw_tuple_inst                                               (hw_tuple_inst)

rec_inst      : LBRACE rec_inst_body RBRACE                                 (A.RecordExp{fields = rec_inst_body, pos = LBRACEleft})

rec_inst_body : ID EQ exp rec_field_comma_tail                              ([(Symbol.symbol(ID), exp, IDleft)] @ rec_field_comma_tail)
              | epsilon                                                     ([])

rec_field_comma_tail
              : COMMA ID EQ exp rec_field_comma_tail                        ([(Symbol.symbol(ID), exp, IDleft)] @ rec_field_comma_tail)
              | epsilon                                                     ([])

ref_inst      : REF exp                                                     (A.RefExp(exp, REFleft))

array_inst    : POUND LBRACK list_elements RBRACK                           (A.ArrayExp(Vector.fromList(list_elements)))
              | POUND LBRACK exp COMMA matches RBRACK                       ()
              | bit_array_inst                                              (bit_array_inst)

list_inst     : LBRACK list_elements RBRACK                                 (A.ListExp(list_elements))
              | NIL                                                         (A.ListExp([]))

list_elements : exp exp_comma_tail                                          ([(exp1, exp1left)] @ exp_comma_tail)
              | epsilon                                                     ([])

sw_tuple_inst : LPAREN list_elements RPAREN                                 (A.RecordExp{fields = numberedFields(list_elements), pos = LPARENleft})

hw_tuple_inst : POUND LPAREN list_elements RPAREN                           (A.HWTupleExp(list_elements))

bit_array_inst: exp TID COLON exp                                           ()

with_value    : exp WITH rec_inst                                           (A.WithExp{exp = exp, fields = valOf(extractFields(rec_inst)), pos = expleft})

pattern_match : CASE exp OF matches                                         (A.PatternMatchExp{exp = exp, cases = matches, pos = CASEleft})

matches       : exp FAT_ARROW exp matches_tail                              ([{match = exp1, result = exp2, pos = exp1left}] @ matches_tail)

matches_tail  : matches_tail PIPE_EQUALS exp FAT_ARROW exp                  (matches_tail @ [{match = exp1, result = exp2, pos = exp1left}])
              | epsilon                                                     ([])

epsilon       :                                                             ()
