structure P = PrintAbsyn
structure A = Absyn
structure S = GeminiString(String)
structure BA = GeminiBitArray(Vector)

fun extractModDecList (A.ModuleDec list) = SOME(list)
  | extractModDecList _ = NONE

fun extractTypeDecList (A.TypeDec list) = SOME(list)
  | extractTypeDecList _ = NONE

fun extractFunDecList (A.FunctionDec list) = SOME(list)
  | extractFunDecList _ = NONE

fun extractValDecList (A.ValDec list) = SOME(list)
  | extractValDecList _ = NONE

fun extractStructSigList (A.StructsSigsExp list) = SOME(list)
  | extractStructSigList _ = NONE

fun extractDatatypeDecList (A.DatatypeDec list) = SOME(list)
  | extractDatatypeDecList _ = NONE

fun extractSWFields (A.SWRecordExp{fields, pos}) = SOME(fields)
  | extractSWFields _ = NONE

fun extractHWFields (A.HWRecordExp{fields, pos}) = SOME(fields)
  | extractHWFields _ = NONE

fun param [] = A.NoParam
  | param [f] = A.SingleParam(f)
  | param fields = A.MultiParams(fields)

fun numberedExpFields lst = #2 (foldl (fn((expr, posn), (idx, acc)) => (idx + 1, acc @ [(Symbol.symbol(Int.toString(idx)), expr, posn)])) (1, []) lst)

fun numberedTyField i t p = {name = Symbol.symbol(Int.toString(i)), ty = t, escape = ref true, pos = p}

fun numberedTyFields tps = #2 (foldl (fn((t, p), (idx, acc)) => (idx + 1, acc @ [numberedTyField idx t p])) (1, []) tps)

fun renumberTyFields fields offset = map (fn({name, ty, escape, pos}) => {name = Symbol.symbol(Int.toString(valOf(Int.fromString(Symbol.name name)) + offset)), ty = ty, escape = escape, pos = pos}) fields

fun sw_coalesce((A.SWRecordTy(fields1, rp1), p1), (A.SWRecordTy(fields2, rp2), p2)) = A.SWRecordTy(fields1 @ (renumberTyFields fields2 (length(fields1))), rp1)
  | sw_coalesce((A.SWRecordTy(fields, rp), p), (ty', p')) = A.SWRecordTy(fields @ [numberedTyField (length(fields) + 1) ty' p'], rp)
  | sw_coalesce((ty', p'), (A.SWRecordTy(fields, rp), p)) = A.SWRecordTy([numberedTyField 1 ty' p'] @ (renumberTyFields fields 1), p')
  | sw_coalesce((t1, p1), (t2, p2)) = A.SWRecordTy(numberedTyFields([(t1, p1), (t2, p2)]), p1)


fun hw_coalesce((A.HWRecordTy(fields1, rp1), p1), (A.HWRecordTy(fields2, rp2), p2)) = A.HWRecordTy(fields1 @ (renumberTyFields fields2 (length(fields1))), rp1)
  | hw_coalesce((A.HWRecordTy(fields, rp), p), (ty', p')) = A.HWRecordTy(fields @ [numberedTyField (length(fields) + 1) ty' p'], rp)
  | hw_coalesce((ty', p'), (A.HWRecordTy(fields, rp), p)) = A.HWRecordTy([numberedTyField 1 ty' p'] @ (renumberTyFields fields 1), p')
  | hw_coalesce((t1, p1), (t2, p2)) = A.HWRecordTy(numberedTyFields([(t1, p1), (t2, p2)]), p1)

%%
%term
    EOF
  | DATATYPE | TYPE | VAL | REF | FUN | MODULE | STRUCTURE | STRUCT | SIGNATURE | SIG | LIST | SW
  | LET | IN | END | IF | THEN | ELSE
  | ORELSE | ANDALSO | NOT
  | NIL | WITH | OF | OP | CASE
  | PIPE_EQUALS | FAT_ARROW | THIN_ARROW
  | BIT_OR_REDUCE | BIT_AND_REDUCE | BIT_XOR_REDUCE
  | BIT_DOUBLE_AND | BIT_DOUBLE_OR | BIT_DOUBLE_XOR
  | BIT_NOT | BIT_OR | BIT_AND | BIT_XOR | BIT_SLL | BIT_SRL | BIT_SRA
  | GE | GT | LE | LT | NEQ | EQ
  | UMINUS | INT_DIVIDE | INT_TIMES | INT_PLUS | INT_MINUS | INT_MOD | REAL_DIVIDE | REAL_TIMES | REAL_PLUS | REAL_MINUS
  | RBRACE | LBRACE | RBRACK | LBRACK | RPAREN | LPAREN
  | DOT | SEMICOLON | COLON | COMMA | POUND | AT | ASSIGN | BANG | CONS | POUND_TIMES | AND
  | ID of string | TID of string | INT of int | STRING of string | REAL of real | BIT of GeminiBit.bit
  | APPLY | REC_ACC | DEREF

%nonterm
      program of A.exp
        | structs_or_sigs of A.exp
            | structures of A.structsig list
                | structure_nt of A.structsig
                    | struct_body of A.dec list
            | signatures of A.structsig list
                | signature_nt of A.structsig
                    | sig_body of A.def list
                    | sigs of A.def list
                        | val_sig of A.def
                        | ty_sig of A.def
                        | module_sig of A.def
        | exp of A.exp
            | access of A.exp
                | array_access of A.exp
                | struct_access of A.exp
                | tuple_access of A.exp
                | record_access of A.exp
                | deref of A.exp
            | operation of A.exp
                | int_op of A.exp
                | real_op of A.exp
                | bit_op of A.exp
                | compare_op of A.exp
                | list_op of A.exp
            | let_block of A.exp
                | let_body of A.exp
                    | semicolon_exp0 of (A.exp * int) list
                | decs of A.dec list
                    | val_dec of A.dec
                    | fun_dec of A.dec
                        | fun_dec_no_type of A.dec
                        | fun_dec_with_type of A.dec
                        | fun_params of A.param list
                            | fun_param of A.param
                    | ty_dec of A.dec
                        | ty of A.ty
                            | no_ty_fields of A.field list
                            | ty_fields of A.field list
                            | ty_field_tail of A.field list
                        | with_type of A.opdef list
                            | with_type_tail of A.opdef list
                    | dataty_dec of A.dec
                        | dataty_tail of A.datacon list
                    | module_dec of A.dec
                        | module_dec_no_type of A.moddec
                        | module_dec_with_type of A.moddec
                    | non_val_dec of A.dec list
                    | non_fun_dec of A.dec list
                    | non_ty_dec of A.dec list
                    | non_dataty_dec of A.dec list
                    | non_module_dec of A.dec list
            | exp_seq of A.exp
            | assign of A.exp
            | conditional of A.exp
            | insts of A.exp
                | rec_inst of A.exp
                    | rec_inst_body of (Symbol.symbol * A.exp * int) list
                    | rec_field_comma_tail of (Symbol.symbol * A.exp * int) list
                | ref_inst of A.exp
                | array_inst of A.exp
                    | bit_array_inst of A.exp
                | list_inst of A.exp
                    | list_elements of (A.exp * int) list
                | sw_tuple_inst of A.exp
                | hw_tuple_inst of A.exp
                | sw_inst of A.exp
                | exp_comma_tail of (A.exp * int) list
            | with_value of A.exp
            | pattern_match of A.exp
                | matches of A.match list
                | matches_tail of A.match list
        | epsilon

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Gemini

%keyword DATATYPE TYPE VAL REF FUN MODULE STRUCTURE STRUCT SIGNATURE SIG
  LET IN END IF THEN ELSE
  ORELSE ANDALSO NOT
  NIL WITH OF OP

%prefer THEN ELSE LPAREN

%value ID ("foo")
%value INT (1)
%value STRING ("")
%value BIT (GeminiBit.fromInt(0))
%value REAL (1.0)

%change -> IN ID END
      | EQ -> ASSIGN
      | ASSIGN -> EQ
      | SEMICOLON ELSE -> ELSE
      | LET ID EQ -> LET TYPE ID EQ
      | LET ID ASSIGN -> LET VAL ID ASSIGN
      | LET ID COLON ID ASSIGN -> LET VAL ID COLON ID ASSIGN
      | LET ID LPAREN -> LET FUN ID LPAREN
      | COMMA -> SEMICOLON
      | SEMICOLON -> COMMA
      | SEMICOLON -> COLON
      | COLON -> SEMICOLON
      | SEMICOLON THEN -> THEN
      | SEMICOLON VAL -> VAL
      | SEMICOLON TYPE -> TYPE
      | SEMICOLON FUN -> FUN
      | SEMICOLON DATATYPE -> DATATYPE
      | SEMICOLON MODULE -> MODULE
      | SEMICOLON END -> END
      | SEMICOLON IN -> IN

%nonassoc INT STRING REAL BIT ID TID
%nonassoc OF
%nonassoc THEN
%nonassoc ELSE
%nonassoc LBRACK RBRACK

%right ASSIGN
%right WITH
%right THIN_ARROW

%right CONS
%left ORELSE
%left ANDALSO
%left BIT_SLL BIT_SRA BIT_SRL

%left EQ NEQ
%left GT LT GE LE
%left BIT_DOUBLE_OR BIT_DOUBLE_XOR
%left BIT_DOUBLE_AND
%left REAL_MINUS REAL_PLUS INT_MINUS INT_PLUS BIT_XOR BIT_OR POUND_TIMES
%left REAL_DIVIDE REAL_TIMES INT_DIVIDE INT_TIMES BIT_AND INT_MOD

%right DEREF
%right REC_ACC
%left AT
%left LIST SW REF

%left UMINUS BIT_NOT BIT_OR_REDUCE BIT_AND_REDUCE BIT_XOR_REDUCE
%left APPLY

%%

program	      : structs_or_sigs                                             (P.print(TextIO.stdOut, structs_or_sigs); structs_or_sigs)
              | exp                                                         (P.print(TextIO.stdOut, exp); exp)

exp           : exp exp %prec APPLY                                         (A.ApplyExp(exp1, exp2, exp1left))
              | INT                                                         (A.IntExp(INT, INTleft))
              | STRING                                                      (A.StringExp(STRING, STRINGleft))
              | REAL                                                        (A.RealExp(REAL, REALleft))
              | BIT                                                         (A.BitExp(BIT, BITleft))
              | ID                                                          (A.VarExp(Symbol.symbol(ID), IDleft))
              | access                                                      (access)
              | operation                                                   (operation)
              | let_block                                                   (let_block)
              | assign                                                      (assign)
              | exp_seq                                                     (exp_seq)
              | conditional                                                 (conditional)
              | insts                                                       (insts)
              | with_value                                                  (with_value)
              | pattern_match                                               (pattern_match)
              | LPAREN RPAREN                                               (A.SeqExp[])

structs_or_sigs
              : structures structs_or_sigs                                  (A.StructsSigsExp(structures @ valOf(extractStructSigList(structs_or_sigs))))
              | signatures structs_or_sigs                                  (A.StructsSigsExp(signatures @ valOf(extractStructSigList(structs_or_sigs))))
              | epsilon                                                     (A.StructsSigsExp([]))

structures    : structure_nt structures                                     ([structure_nt] @ structures)
              | structure_nt                                                ([structure_nt])

structure_nt  : STRUCTURE ID EQ struct_body                                 (A.StructExp{name = Symbol.symbol(ID), signat = NONE, decs = struct_body, pos = STRUCTUREleft})
              | STRUCTURE ID COLON ID EQ struct_body                        (A.StructExp{name = Symbol.symbol(ID1), signat = SOME(A.NamedSigExp(Symbol.symbol(ID2)), ID2left), decs = struct_body, pos = STRUCTUREleft})
              | STRUCTURE ID COLON sig_body EQ struct_body                  (A.StructExp{name = Symbol.symbol(ID), signat = SOME(A.AnonSigExp(sig_body), sig_bodyleft), decs = struct_body, pos = STRUCTUREleft})

struct_body   : STRUCT decs END                                             (decs)

signatures    : signature_nt signatures                                     ([signature_nt] @ signatures)
              | signature_nt                                                ([signature_nt])

signature_nt  : SIGNATURE ID EQ sig_body                                    (A.SigExp{name = Symbol.symbol(ID), defs = sig_body})

sig_body      : SIG sigs END                                                (sigs)

sigs          : val_sig sigs                                                (val_sig::sigs)
              | ty_sig sigs                                                 (ty_sig::sigs)
              | module_sig sigs                                             (module_sig::sigs)
              | epsilon                                                     ([])

val_sig       : VAL ID COLON ty                                             (A.ValDef{name = Symbol.symbol(ID), ty = (ty, tyleft), pos = VALleft})

ty_sig        : TYPE ID                                                     (A.TypeDef{name = Symbol.symbol(ID), pos = TYPEleft})

module_sig    : MODULE ID COLON ty THIN_ARROW ty                            (A.ModuleDef{name = Symbol.symbol(ID), input_ty = ty1, output_ty = ty2, pos = MODULEleft})

array_access  : exp LBRACK exp RBRACK                                       (A.ArrayAccExp{exp = exp1, index = exp2, pos = exp1left})

struct_access : ID DOT ID                                                   (A.StructAccExp{name = Symbol.symbol(ID1), field = Symbol.symbol(ID2), pos = ID1left})

tuple_access  : POUND INT exp %prec REC_ACC                                 (A.RecordAccExp{exp = exp, field = Symbol.symbol(Int.toString(INT)), pos = POUNDleft})

record_access : POUND ID exp %prec REC_ACC                                  (A.RecordAccExp{exp = exp, field = Symbol.symbol(ID), pos = POUNDleft})

deref         : BANG exp %prec DEREF                                        (A.DerefExp{exp = exp, pos = BANGleft})

access        : array_access                                                (array_access)
              | struct_access                                               (struct_access)
              | tuple_access                                                (tuple_access)
              | record_access                                               (record_access)
              | deref                                                       (deref)

operation     : int_op                                                      (int_op)
              | real_op                                                     (real_op)
              | bit_op                                                      (bit_op)
              | compare_op                                                  (compare_op)
              | list_op                                                     (list_op)

int_op        : UMINUS exp                                                  (A.UnOpExp{exp = exp1, oper = A.IntMinusOp, pos = UMINUSleft})
              | exp INT_PLUS exp                                            (A.BinOpExp{left = exp1, oper = A.IntPlusOp, right = exp2, pos = exp1left})
              | exp INT_MINUS exp                                           (A.BinOpExp{left = exp1, oper = A.IntMinusOp, right = exp2, pos = exp1left})
              | exp INT_TIMES exp                                           (A.BinOpExp{left = exp1, oper = A.IntTimesOp, right = exp2, pos = exp1left})
              | exp INT_DIVIDE exp                                          (A.BinOpExp{left = exp1, oper = A.IntDivideOp, right = exp2, pos = exp1left})
              | exp INT_MOD exp                                             (A.BinOpExp{left = exp1, oper = A.IntModOp, right = exp2, pos = exp1left})

real_op       : exp REAL_PLUS exp                                           (A.BinOpExp{left = exp1, oper = A.RealPlusOp, right = exp2, pos = exp1left})
              | exp REAL_MINUS exp                                          (A.BinOpExp{left = exp1, oper = A.RealMinusOp, right = exp2, pos = exp1left})
              | exp REAL_TIMES exp                                          (A.BinOpExp{left = exp1, oper = A.RealTimesOp, right = exp2, pos = exp1left})
              | exp REAL_DIVIDE exp                                         (A.BinOpExp{left = exp1, oper = A.RealDivideOp, right = exp2, pos = exp1left})

bit_op        : BIT_NOT exp                                                 (A.UnOpExp{exp = exp1, oper = A.BitNotOp, pos = BIT_NOTleft})
              | BIT_OR_REDUCE exp                                           (A.UnOpExp{exp = exp1, oper = A.BitOrReduceOp, pos = BIT_OR_REDUCEleft})
              | BIT_AND_REDUCE exp                                          (A.UnOpExp{exp = exp1, oper = A.BitAndReduceOp, pos = BIT_AND_REDUCEleft})
              | BIT_XOR_REDUCE exp                                          (A.UnOpExp{exp = exp1, oper = A.BitXorReduceOp, pos = BIT_XOR_REDUCEleft})
              | exp BIT_DOUBLE_OR exp                                       (A.BinOpExp{left = exp1, oper = A.BitDoubleOrOp, right = exp2, pos = exp1left})
              | exp BIT_DOUBLE_AND exp                                      (A.BinOpExp{left = exp1, oper = A.BitDoubleAndOp, right = exp2, pos = exp1left})
              | exp BIT_DOUBLE_XOR exp                                      (A.BinOpExp{left = exp1, oper = A.BitDoubleXorOp, right = exp2, pos = exp1left})
              | exp BIT_OR exp                                              (A.BinOpExp{left = exp1, oper = A.BitOrOp, right = exp2, pos = exp1left})
              | exp BIT_AND exp                                             (A.BinOpExp{left = exp1, oper = A.BitAndOp, right = exp2, pos = exp1left})
              | exp BIT_XOR exp                                             (A.BinOpExp{left = exp1, oper = A.BitXorOp, right = exp2, pos = exp1left})
              | exp BIT_SLL exp                                             (A.BinOpExp{left = exp1, oper = A.BitSLLOp, right = exp2, pos = exp1left})
              | exp BIT_SRL exp                                             (A.BinOpExp{left = exp1, oper = A.BitSRLOp, right = exp2, pos = exp1left})
              | exp BIT_SRA exp                                             (A.BinOpExp{left = exp1, oper = A.BitSRAOp, right = exp2, pos = exp1left})

compare_op    : exp EQ exp                                                  (A.BinOpExp{left = exp1, oper = A.EqOp, right = exp2, pos = exp1left})
              | exp NEQ exp                                                 (A.BinOpExp{left = exp1, oper = A.NeqOp, right = exp2, pos = exp1left})
              | exp GT exp                                                  (A.BinOpExp{left = exp1, oper = A.GtOp, right = exp2, pos = exp1left})
              | exp LT exp                                                  (A.BinOpExp{left = exp1, oper = A.LtOp, right = exp2, pos = exp1left})
              | exp GE exp                                                  (A.BinOpExp{left = exp1, oper = A.GeOp, right = exp2, pos = exp1left})
              | exp LE exp                                                  (A.BinOpExp{left = exp1, oper = A.LeOp, right = exp2, pos = exp1left})

list_op       : exp CONS exp                                                (A.BinOpExp{left = exp1, oper = A.ConsOp, right = exp2, pos = exp1left})

let_block     : LET decs IN exp END                                         (A.LetExp{decs = decs, body = exp1, pos = LETleft})

decs          : val_dec non_val_dec                                         (val_dec::non_val_dec)
              | fun_dec non_fun_dec                                         (fun_dec::non_fun_dec)
              | ty_dec non_ty_dec                                           (ty_dec::non_ty_dec)
              | dataty_dec non_dataty_dec                                   (dataty_dec::non_dataty_dec)
              | module_dec non_module_dec                                   (module_dec::non_module_dec)
              | epsilon                                                     ([])

non_val_dec   : fun_dec non_fun_dec                                         (fun_dec::non_fun_dec)
              | ty_dec non_ty_dec                                           (ty_dec::non_ty_dec)
              | dataty_dec non_dataty_dec                                   (dataty_dec::non_dataty_dec)
              | module_dec non_module_dec                                   (module_dec::non_module_dec)
              | epsilon                                                     ([])

non_fun_dec   : val_dec non_val_dec                                         (val_dec::non_val_dec)
              | ty_dec non_ty_dec                                           (ty_dec::non_ty_dec)
              | dataty_dec non_dataty_dec                                   (dataty_dec::non_dataty_dec)
              | module_dec non_module_dec                                   (module_dec::non_module_dec)
              | epsilon                                                     ([])

non_ty_dec    : val_dec non_val_dec                                         (val_dec::non_val_dec)
              | fun_dec non_fun_dec                                         (fun_dec::non_fun_dec)
              | dataty_dec non_dataty_dec                                   (dataty_dec::non_dataty_dec)
              | module_dec non_module_dec                                   (module_dec::non_module_dec)
              | epsilon                                                     ([])

non_dataty_dec: val_dec non_val_dec                                         (val_dec::non_val_dec)
              | ty_dec non_ty_dec                                           (ty_dec::non_ty_dec)
              | fun_dec non_fun_dec                                         (fun_dec::non_fun_dec)
              | module_dec non_module_dec                                   (module_dec::non_module_dec)
              | epsilon                                                     ([])

non_module_dec: val_dec non_val_dec                                         (val_dec::non_val_dec)
              | fun_dec non_fun_dec                                         (fun_dec::non_fun_dec)
              | ty_dec non_ty_dec                                           (ty_dec::non_ty_dec)
              | dataty_dec non_dataty_dec                                   (dataty_dec::non_dataty_dec)
              | epsilon                                                     ([])

val_dec       : VAL ID EQ exp                                               (A.ValDec[{name = Symbol.symbol(ID), escape = ref true, ty = (A.PlaceholderTy(ref ()), IDleft), init = exp1, pos = VALleft}])
              | VAL ID COLON ty EQ exp                                      (A.ValDec[{name = Symbol.symbol(ID), escape = ref true, ty = (ty, tyleft), init = exp1, pos = VALleft}])
              | VAL ID EQ exp val_dec                                       (A.ValDec({name = Symbol.symbol(ID), escape = ref true, ty = (A.PlaceholderTy(ref ()), IDleft), init = exp1, pos = VALleft}::valOf(extractValDecList(val_dec))))
              | VAL ID COLON ty EQ exp val_dec                              (A.ValDec({name = Symbol.symbol(ID), escape = ref true, ty = (ty, tyleft), init = exp1, pos = VALleft}::valOf(extractValDecList(val_dec))))

fun_dec       : fun_dec_no_type                                             (fun_dec_no_type)
              | fun_dec_with_type                                           (fun_dec_with_type)
              | fun_dec_no_type fun_dec                                     (A.FunctionDec(valOf(extractFunDecList(fun_dec_no_type)) @ valOf(extractFunDecList(fun_dec))))
              | fun_dec_with_type fun_dec                                   (A.FunctionDec(valOf(extractFunDecList(fun_dec_with_type)) @ valOf(extractFunDecList(fun_dec))))

fun_dec_no_type
              : FUN ID fun_params EQ exp                                    (A.FunctionDec[{name = Symbol.symbol(ID), params = fun_params1, result = (A.PlaceholderTy(ref()), IDleft), body = exp1, pos = FUNleft}])

fun_dec_with_type
              : FUN ID fun_params COLON ty EQ exp                           (A.FunctionDec[{name = Symbol.symbol(ID), params = fun_params1, result = (ty1, ty1left), body = exp1, pos = FUNleft}])

fun_params    : fun_params fun_param                                        (fun_params1 @ [fun_param1])
              | fun_param                                                   ([fun_param1])
              | epsilon                                                     ([])

fun_param     : ID                                                          (A.SingleParam{name = Symbol.symbol(ID), ty = A.PlaceholderTy(ref ()), escape = ref true, pos = IDleft})
              | LPAREN no_ty_fields RPAREN                                  (param(no_ty_fields))
              | LPAREN ty_fields RPAREN                                     (param(ty_fields))

ty_dec        : TYPE TID ID EQ ty                                           (A.TypeDec[{name = Symbol.symbol(ID), ty = ty1, tyvar = SOME(Symbol.symbol(TID1)), opdef = NONE, pos = TYPEleft}])
              | TYPE TID ID EQ ty ty_dec                                    (A.TypeDec([{name = Symbol.symbol(ID), ty = ty1, tyvar = SOME(Symbol.symbol(TID1)), opdef = NONE, pos = TYPEleft}] @ valOf(extractTypeDecList(ty_dec))))
              | TYPE TID ID EQ ty with_type                                 (A.TypeDec[{name = Symbol.symbol(ID), ty = ty1, tyvar = SOME(Symbol.symbol(TID1)), opdef = SOME(with_type), pos = TYPEleft}])
              | TYPE TID ID EQ ty with_type ty_dec                          (A.TypeDec([{name = Symbol.symbol(ID), ty = ty1, tyvar = SOME(Symbol.symbol(TID1)), opdef = SOME(with_type), pos = TYPEleft}] @ valOf(extractTypeDecList(ty_dec))))
              | TYPE ID EQ ty                                               (A.TypeDec[{name = Symbol.symbol(ID), ty = ty1, tyvar = NONE, opdef = NONE, pos = TYPEleft}])
              | TYPE ID EQ ty ty_dec                                        (A.TypeDec([{name = Symbol.symbol(ID), ty = ty1, tyvar = NONE, opdef = NONE, pos = TYPEleft}] @ valOf(extractTypeDecList(ty_dec))))
              | TYPE ID EQ ty with_type                                     (A.TypeDec[{name = Symbol.symbol(ID), ty = ty1, tyvar = NONE, opdef = SOME(with_type), pos = TYPEleft}])
              | TYPE ID EQ ty with_type ty_dec                              (A.TypeDec([{name = Symbol.symbol(ID), ty = ty1, tyvar = NONE, opdef = SOME(with_type), pos = TYPEleft}] @ valOf(extractTypeDecList(ty_dec))))

ty            : TID                                                         (A.GenericTy(Symbol.symbol(TID), TIDleft))
              | ID                                                          (A.NameTy(Symbol.symbol(ID), IDleft))
              | ty INT_TIMES ty                                             (sw_coalesce((ty1, ty1left), (ty2, ty2left)))
              | ty POUND_TIMES ty                                           (hw_coalesce((ty1, ty1left), (ty2, ty2left)))
              | LBRACE ty_fields RBRACE                                     (A.SWRecordTy(ty_fields, LBRACEleft))
              | POUND LBRACE ty_fields RBRACE                               (A.HWRecordTy(ty_fields, LBRACEleft))
              | ty AT exp                                                   (A.TemporalTy(ty1, exp1, ty1left))
              | ty LBRACK exp RBRACK                                        (A.ArrayTy(ty1, exp1, ty1left))
              | ty LIST                                                     (A.ListTy(ty1, ty1left))
              | ty REF                                                      (A.RefTy(ty1, ty1left))
              | ty SW                                                       (A.SWTy(ty1, ty1left))
              | ty THIN_ARROW ty                                            (A.FunTy(ty1, ty2, ty1left))
              | LPAREN ty RPAREN                                            (ty)

no_ty_fields  : ID                                                          ([{name = Symbol.symbol(ID), ty = A.PlaceholderTy(ref ()), escape = ref true, pos = IDleft}])
              | no_ty_fields COMMA ID                                       (no_ty_fields1 @ [{name = Symbol.symbol(ID), ty = A.PlaceholderTy(ref ()), escape = ref true, pos = no_ty_fields1left}])

ty_fields     : ty_field_tail                                               (ty_field_tail)
              | epsilon                                                     ([])

ty_field_tail : ID COLON ty                                                 ([{name = Symbol.symbol(ID), ty = ty1, escape = ref true, pos = IDleft}])
              | ty_field_tail COMMA ID COLON ty                             (ty_field_tail1 @ [{name = Symbol.symbol(ID), ty = ty1, escape = ref true, pos = ty_field_tail1left}])

with_type     : WITH OP EQ LPAREN ID COMMA ID RPAREN EQ exp with_type_tail  ([{oper = A.EqOp, param_a = Symbol.symbol(ID1), param_b = Symbol.symbol(ID2), body = exp1, pos = WITHleft}] @ with_type_tail1)
              | WITH OP NEQ LPAREN ID COMMA ID RPAREN EQ exp with_type_tail ([{oper = A.NeqOp, param_a = Symbol.symbol(ID1), param_b = Symbol.symbol(ID2), body = exp1, pos = WITHleft}] @ with_type_tail1)
              | WITH OP GT LPAREN ID COMMA ID RPAREN EQ exp with_type_tail  ([{oper = A.GtOp, param_a = Symbol.symbol(ID1), param_b = Symbol.symbol(ID2), body = exp1, pos = WITHleft}] @ with_type_tail1)
              | WITH OP LT LPAREN ID COMMA ID RPAREN EQ exp with_type_tail  ([{oper = A.LtOp, param_a = Symbol.symbol(ID1), param_b = Symbol.symbol(ID2), body = exp1, pos = WITHleft}] @ with_type_tail1)
              | WITH OP GE LPAREN ID COMMA ID RPAREN EQ exp with_type_tail  ([{oper = A.GeOp, param_a = Symbol.symbol(ID1), param_b = Symbol.symbol(ID2), body = exp1, pos = WITHleft}] @ with_type_tail1)
              | WITH OP LE LPAREN ID COMMA ID RPAREN EQ exp with_type_tail  ([{oper = A.LeOp, param_a = Symbol.symbol(ID1), param_b = Symbol.symbol(ID2), body = exp1, pos = WITHleft}] @ with_type_tail1)

with_type_tail: AND with_type                                               (with_type)
              | epsilon                                                     ([])

dataty_dec    : DATATYPE TID ID EQ ID dataty_tail                           (A.DatatypeDec([{name = Symbol.symbol(ID1), tyvar = SOME(Symbol.symbol(TID1)), datacons = {datacon = Symbol.symbol(ID2), ty = A.PlaceholderTy(ref()), pos = ID2left}::dataty_tail}]))
              | DATATYPE TID ID EQ ID dataty_tail dataty_dec                (A.DatatypeDec({name = Symbol.symbol(ID1), tyvar = SOME(Symbol.symbol(TID1)), datacons = {datacon = Symbol.symbol(ID2), ty = A.PlaceholderTy(ref ()), pos = ID2left}::dataty_tail}::valOf(extractDatatypeDecList(dataty_dec))))
              | DATATYPE TID ID EQ ID OF ty dataty_tail                     (A.DatatypeDec([{name = Symbol.symbol(ID1), tyvar = SOME(Symbol.symbol(TID1)), datacons = {datacon = Symbol.symbol(ID2), ty = ty, pos = ID2left}::dataty_tail}]))
              | DATATYPE TID ID EQ ID OF ty dataty_tail dataty_dec          (A.DatatypeDec({name = Symbol.symbol(ID1), tyvar = SOME(Symbol.symbol(TID1)), datacons = {datacon = Symbol.symbol(ID2), ty = ty, pos = ID2left}::dataty_tail}::valOf(extractDatatypeDecList(dataty_dec))))
              | DATATYPE ID EQ ID dataty_tail                               (A.DatatypeDec([{name = Symbol.symbol(ID1), tyvar = NONE, datacons = {datacon = Symbol.symbol(ID2), ty = A.PlaceholderTy(ref ()), pos = ID2left}::dataty_tail}]))
              | DATATYPE ID EQ ID dataty_tail dataty_dec                    (A.DatatypeDec({name = Symbol.symbol(ID1), tyvar = NONE, datacons = {datacon = Symbol.symbol(ID2), ty = A.PlaceholderTy(ref ()), pos = ID2left}::dataty_tail}::valOf(extractDatatypeDecList(dataty_dec))))
              | DATATYPE ID EQ ID OF ty dataty_tail                         (A.DatatypeDec([{name = Symbol.symbol(ID1), tyvar = NONE, datacons = {datacon = Symbol.symbol(ID2), ty = ty, pos = ID2left}::dataty_tail}]))
              | DATATYPE ID EQ ID OF ty dataty_tail dataty_dec              (A.DatatypeDec({name = Symbol.symbol(ID1), tyvar = NONE, datacons = {datacon = Symbol.symbol(ID2), ty = ty, pos = ID2left}::dataty_tail}::valOf(extractDatatypeDecList(dataty_dec))))

dataty_tail   : PIPE_EQUALS ID OF ty dataty_tail                            ({datacon = Symbol.symbol(ID), ty = ty, pos = IDleft}::dataty_tail)
              | PIPE_EQUALS ID dataty_tail                                  ({datacon = Symbol.symbol(ID), ty = A.PlaceholderTy(ref ()), pos = IDleft}::dataty_tail)
              | epsilon                                                     ([])

module_dec    : module_dec_no_type                                          (A.ModuleDec([module_dec_no_type]))
              | module_dec_with_type                                        (A.ModuleDec([module_dec_with_type]))
              | module_dec_no_type module_dec                               (A.ModuleDec(module_dec_no_type::valOf(extractModDecList(module_dec))))
              | module_dec_with_type module_dec                             (A.ModuleDec(module_dec_with_type::valOf(extractModDecList(module_dec))))

module_dec_no_type
              : MODULE ID fun_param EQ exp                                  ({name = Symbol.symbol(ID), arg = fun_param, result = (A.PlaceholderTy(ref ()), IDleft), body = exp, pos = MODULEleft})

module_dec_with_type
              : MODULE ID fun_param COLON ty EQ exp                         ({name = Symbol.symbol(ID), arg = fun_param, result = (ty, tyleft), body = exp, pos = MODULEleft})

semicolon_exp0: SEMICOLON exp semicolon_exp0                                ([(exp1, exp1left)] @ semicolon_exp0)
              | epsilon                                                     ([])

exp_seq       : LPAREN exp RPAREN                                           (exp)
              | LPAREN exp SEMICOLON exp semicolon_exp0 RPAREN              (A.SeqExp([(exp1, exp1left)] @ [(exp2, exp2left)] @ semicolon_exp0))

assign        : exp ASSIGN exp                                              (A.AssignExp{lhs = exp1, rhs = exp2, pos = exp1left})

exp_comma_tail: COMMA exp exp_comma_tail                                    ([(exp1, exp1left)] @ exp_comma_tail)
              | epsilon                                                     ([])

conditional   : IF exp THEN exp ELSE exp                                    (A.IfExp{test = exp1, then' = exp2, else' = SOME(exp3), pos = IFleft})
              | IF exp THEN exp                                             (A.IfExp{test = exp1, then' = exp2, else' = NONE, pos = IFleft})
              | exp ANDALSO exp                                             (A.IfExp{test = exp1, then' = exp2, else' = SOME(A.IntExp(0, 0)), pos = exp1left})
              | exp ORELSE exp                                              (A.IfExp{test = exp1, then' = A.IntExp(1, 0), else' = SOME(exp2), pos = exp1left})

insts         : rec_inst                                                    (rec_inst)
              | ref_inst                                                    (ref_inst)
              | array_inst                                                  (array_inst)
              | list_inst                                                   (list_inst)
              | sw_tuple_inst                                               (sw_tuple_inst)
              | hw_tuple_inst                                               (hw_tuple_inst)
              | sw_inst                                                     (sw_inst)

rec_inst      : LBRACE rec_inst_body RBRACE                                 (A.SWRecordExp{fields = rec_inst_body, pos = LBRACEleft})

rec_inst_body : ID EQ exp rec_field_comma_tail                              ([(Symbol.symbol(ID), exp, IDleft)] @ rec_field_comma_tail)
              | epsilon                                                     ([])

rec_field_comma_tail
              : COMMA ID EQ exp rec_field_comma_tail                        ([(Symbol.symbol(ID), exp, IDleft)] @ rec_field_comma_tail)
              | epsilon                                                     ([])

ref_inst      : REF exp                                                     (A.RefExp(exp, REFleft))

array_inst    : POUND LBRACK list_elements RBRACK                           (A.ArrayExp(Vector.fromList(list_elements)))
              | POUND LBRACK exp SEMICOLON exp RBRACK                       (A.BitArrayExp{size = exp1, result = exp2, spec = NONE})
              | bit_array_inst                                              (bit_array_inst)

list_inst     : LBRACK list_elements RBRACK                                 (A.ListExp(list_elements))
              | NIL                                                         (A.ListExp([]))

list_elements : exp exp_comma_tail                                          ([(exp1, exp1left)] @ exp_comma_tail)
              | epsilon                                                     ([])

sw_tuple_inst : LPAREN list_elements RPAREN                                 (A.SWRecordExp{fields = numberedExpFields(list_elements), pos = LPARENleft})

hw_tuple_inst : POUND LPAREN list_elements RPAREN                           (A.HWRecordExp{fields = numberedExpFields(list_elements), pos = LPARENleft})

sw_inst       : SW exp                                                      (A.SWExp(exp, SWleft))

bit_array_inst: exp TID COLON exp                                           (A.BitArrayExp{size = exp1, result = exp2, spec = SOME(TID)})

with_value    : exp WITH rec_inst                                           (A.WithExp{exp = exp, fields = valOf(extractSWFields(rec_inst)), pos = expleft})

pattern_match : CASE exp OF matches                                         (A.PatternMatchExp{exp = exp, cases = matches, pos = CASEleft})

matches       : exp FAT_ARROW exp matches_tail                              ([{match = exp1, result = exp2, pos = exp1left}] @ matches_tail)

matches_tail  : matches_tail PIPE_EQUALS exp FAT_ARROW exp                  (matches_tail @ [{match = exp1, result = exp2, pos = exp1left}])
              | epsilon                                                     ([])

epsilon       :                                                             ()
