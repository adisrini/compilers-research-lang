structure A = Absyn
structure S = GeminiString(String)
structure BA = GeminiBitArray(Vector)

fun extractModDecList (A.ModuleDec list) = SOME(list)
  | extractModDecList _ = NONE

fun extractTypeDecList (A.TypeDec list) = SOME(list)
  | extractTypeDecList _ = NONE

fun extractFunDecList (A.FunctionDec list) = SOME(list)
  | extractFunDecList _ = NONE

fun extractValDecList (A.ValDec list) = SOME(list)
  | extractValDecList _ = NONE

fun extractStructSigList (A.StructsSigsExp list) = SOME(list)
  | extractStructSigList _ = NONE

fun extractDatatypeDecList (A.SWDatatypeDec list) = SOME(list)
  | extractDatatypeDecList (A.HWDatatypeDec list) = SOME(list)
  | extractDatatypeDecList _ = NONE

fun extractSWFields (A.SWRecordExp{fields, pos}) = SOME(fields)
  | extractSWFields _ = NONE

fun extractHWFields (A.HWRecordExp{fields, pos}) = SOME(fields)
  | extractHWFields _ = NONE

fun param([], _) = A.NoParam
  | param([f], _) = A.SingleParam(f)
  | param(fields, 0)  = A.TupleParams(fields)
  | param(fields, _) = A.RecordParams(fields)

fun numberedExpFields lst = #2 (foldl (fn((expr, posn), (idx, acc)) => (idx + 1, acc @ [(Symbol.symbol(Int.toString(idx)), expr, posn)])) (1, []) lst)

fun numberedTyField i t p = {name = Symbol.symbol(Int.toString(i)), ty = t, escape = ref true, pos = p}

fun numberedTyFields tps = #2 (foldl (fn((t, p), (idx, acc)) => (idx + 1, acc @ [numberedTyField idx t p])) (1, []) tps)

fun renumberTyFields fields offset = map (fn({name, ty, escape, pos}) => {name = Symbol.symbol(Int.toString(valOf(Int.fromString(Symbol.name name)) + offset)), ty = ty, escape = escape, pos = pos}) fields

fun sw_coalesce((A.SWRecordTy(fields1, rp1), p1), (A.SWRecordTy(fields2, rp2), p2)) = A.SWRecordTy(fields1 @ (renumberTyFields fields2 (length(fields1))), rp1)
  | sw_coalesce((A.SWRecordTy(fields, rp), p), (ty', p')) = A.SWRecordTy(fields @ [numberedTyField (length(fields) + 1) ty' p'], rp)
  | sw_coalesce((ty', p'), (A.SWRecordTy(fields, rp), p)) = A.SWRecordTy([numberedTyField 1 ty' p'] @ (renumberTyFields fields 1), p')
  | sw_coalesce((t1, p1), (t2, p2)) = A.SWRecordTy(numberedTyFields([(t1, p1), (t2, p2)]), p1)


fun hw_coalesce((A.HWRecordTy(fields1, rp1), p1), (A.HWRecordTy(fields2, rp2), p2)) = A.HWRecordTy(fields1 @ (renumberTyFields fields2 (length(fields1))), rp1)
  | hw_coalesce((A.HWRecordTy(fields, rp), p), (ty', p')) = A.HWRecordTy(fields @ [numberedTyField (length(fields) + 1) ty' p'], rp)
  | hw_coalesce((ty', p'), (A.HWRecordTy(fields, rp), p)) = A.HWRecordTy([numberedTyField 1 ty' p'] @ (renumberTyFields fields 1), p')
  | hw_coalesce((t1, p1), (t2, p2)) = A.HWRecordTy(numberedTyFields([(t1, p1), (t2, p2)]), p1)

%%
%term
    EOF
  | SDATATYPE | HDATATYPE | TYPE | VAL | REF | FUN | MODULE | STRUCTURE | STRUCT | SIGNATURE | SIG | LIST | SW
  | LET | IN | END | IF | THEN | ELSE
  | ORELSE | ANDALSO | NOT
  | NIL | WITH | OF | OP | CASE
  | PIPE_EQUALS | FAT_ARROW | THIN_ARROW
  | BIT_OR_REDUCE | BIT_AND_REDUCE | BIT_XOR_REDUCE
  | BIT_DOUBLE_AND | BIT_DOUBLE_OR | BIT_DOUBLE_XOR
  | BIT_NOT | BIT_OR | BIT_AND | BIT_XOR | BIT_SLL | BIT_SRL | BIT_SRA
  | GE | GT | LE | LT | NEQ | EQ
  | UMINUS | INT_DIVIDE | INT_TIMES | INT_PLUS | INT_MINUS | INT_MOD | REAL_DIVIDE | REAL_TIMES | REAL_PLUS | REAL_MINUS
  | RBRACE | LBRACE | RBRACK | LBRACK | RPAREN | LPAREN
  | DOT | SEMICOLON | COLON | COMMA | POUND | AT | ASSIGN | BANG | CONS | POUND_TIMES | AND
  | ID of string | TID of string | INT of int | STRING of string | REAL of real | BIT of GeminiBit.bit
  | APPLY | RECORD_ACC | ARRAY_ACC | MATCH_TAIL | MATCH | BIT_ARRAY_INST | EPSILON

%nonterm
      program of A.exp
        | structs_or_sigs of A.exp
            | structures of A.structsig list
                | structure_nt of A.structsig
                    | struct_body of A.dec list
            | signatures of A.structsig list
                | signature_nt of A.structsig
                    | sig_body of A.def list
                    | sigs of A.def list
                        | val_sig of A.def
                        | ty_sig of A.def
                        | module_sig of A.def
        | exp of A.exp
            | access of A.exp
                | array_access of A.exp
                | struct_access of A.exp
                | tuple_access of A.exp
                | record_access of A.exp
                | deref of A.exp
            | operation of A.exp
                | int_op of A.exp
                | real_op of A.exp
                | bit_op of A.exp
                | compare_op of A.exp
                | list_op of A.exp
            | let_block of A.exp
                | let_body of A.exp
                    | semicolon_exp0 of (A.exp * int) list
                | decs of A.dec list
                    | val_dec of A.dec
                    | fun_dec of A.dec
                        | fun_dec_no_type of A.dec
                        | fun_dec_with_type of A.dec
                        | fun_params of A.param list
                            | fun_param of A.param
                    | ty_dec of A.dec
                        | ty of A.ty
                          | typarams of A.ty
                          | typarams_tail of A.ty list
                          | tids of Symbol.symbol list
                          | tids_tail of Symbol.symbol list
                            | opt_ty_fields of A.field list
                            | opt_ty_field_tail of A.field list
                            | ty_fields of A.field list
                            | ty_field_tail of A.field list
                        | with_type of A.opdef list
                            | with_type_tail of A.opdef list
                    | sdataty_dec of A.dec
                    | hdataty_dec of A.dec
                        | dataty_tail of A.datacon list
                    | module_dec of A.dec
                        | module_dec_no_type of A.moddec
                        | module_dec_with_type of A.moddec
                    | non_val_dec of A.dec list
                    | non_fun_dec of A.dec list
                    | non_ty_dec of A.dec list
                    | non_sdataty_dec of A.dec list
                    | non_hdataty_dec of A.dec list
                    | non_module_dec of A.dec list
            | exp_seq of A.exp
            | assign of A.exp
            | conditional of A.exp
            | insts of A.exp
                | sw_rec_inst of A.exp
                | hw_rec_inst of A.exp
                    | rec_inst_body of (Symbol.symbol * A.exp * int) list
                    | rec_field_comma_tail of (Symbol.symbol * A.exp * int) list
                | ref_inst of A.exp
                | array_inst of A.exp
                    | bit_array_inst of A.exp
                | list_inst of A.exp
                    | list_elements of (A.exp * int) list
                | sw_tuple_inst of A.exp
                | hw_tuple_inst of A.exp
                | sw_inst of A.exp
                | exp_comma_tail of (A.exp * int) list
            | with_value of A.exp
            | pattern_match of A.exp
                | matches of A.match list
                | matches_tail of A.match list
                | pattern of A.exp
                    | opt_patterns of (A.exp * int) list
                    | opt_patterns_tail of (A.exp * int) list
                    | rec_patterns of (Symbol.symbol * A.exp * int) list
                    | rec_patterns_tail of (Symbol.symbol * A.exp * int) list
        | epsilon

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Gemini

%keyword SDATATYPE HDATATYPE TYPE VAL REF FUN MODULE STRUCTURE STRUCT SIGNATURE SIG
  LET IN END IF THEN ELSE
  ORELSE ANDALSO NOT
  NIL WITH OF OP

%prefer THEN ELSE LPAREN

%value ID ("foo")
%value INT (1)
%value STRING ("")
%value BIT (GeminiBit.fromInt(0))
%value REAL (1.0)

%change -> IN ID END
      | EQ -> ASSIGN
      | ASSIGN -> EQ
      | SEMICOLON ELSE -> ELSE
      | LET ID EQ -> LET TYPE ID EQ
      | LET ID ASSIGN -> LET VAL ID ASSIGN
      | LET ID COLON ID ASSIGN -> LET VAL ID COLON ID ASSIGN
      | LET ID LPAREN -> LET FUN ID LPAREN
      | COMMA -> SEMICOLON
      | SEMICOLON -> COMMA
      | SEMICOLON -> COLON
      | COLON -> SEMICOLON
      | SEMICOLON THEN -> THEN
      | SEMICOLON VAL -> VAL
      | SEMICOLON TYPE -> TYPE
      | SEMICOLON FUN -> FUN
      | SEMICOLON SDATATYPE -> SDATATYPE
      | SEMICOLON HDATATYPE -> HDATATYPE
      | SEMICOLON MODULE -> MODULE
      | SEMICOLON END -> END
      | SEMICOLON IN -> IN

%nonassoc EPSILON
%nonassoc MATCH_TAIL
%nonassoc MATCH
%nonassoc PIPE_EQUALS
%nonassoc INT STRING REAL BIT ID TID NIL
%nonassoc OF
%nonassoc LET
%nonassoc THEN
%nonassoc ELSE
%nonassoc IF

%right ASSIGN
%right WITH
%right THIN_ARROW

%left ORELSE
%left ANDALSO
%left BIT_SLL BIT_SRA BIT_SRL

%left EQ NEQ
%left GT LT GE LE
%right CONS
%left BIT_DOUBLE_OR BIT_DOUBLE_XOR
%left BIT_DOUBLE_AND
%left REAL_MINUS REAL_PLUS INT_MINUS INT_PLUS BIT_XOR BIT_OR POUND_TIMES
%left REAL_DIVIDE REAL_TIMES INT_DIVIDE INT_TIMES BIT_AND INT_MOD

%nonassoc CASE
%left AT
%left LIST SW REF

%nonassoc ARRAY_ACC LBRACK RBRACK
%nonassoc RECORD_ACC POUND
%nonassoc BANG
%nonassoc BIT_ARRAY_INST

%nonassoc LBRACE RBRACE
%nonassoc LPAREN RPAREN

%left APPLY

%nonassoc UMINUS BIT_NOT BIT_OR_REDUCE BIT_AND_REDUCE BIT_XOR_REDUCE

%%

program	      : structs_or_sigs                                             (structs_or_sigs)
              | exp                                                         (exp)

exp           : exp exp %prec APPLY                                         (A.ApplyExp(exp1, exp2, exp1left))
              | INT                                                         (A.IntExp(INT, INTleft))
              | STRING                                                      (A.StringExp(STRING, STRINGleft))
              | REAL                                                        (A.RealExp(REAL, REALleft))
              | BIT                                                         (A.BitExp(BIT, BITleft))
              | ID                                                          (A.VarExp(Symbol.symbol(ID), IDleft))
              | access                                                      (access)
              | operation                                                   (operation)
              | let_block                                                   (let_block)
              | assign                                                      (assign)
              | exp_seq                                                     (exp_seq)
              | conditional                                                 (conditional)
              | insts                                                       (insts)
              | with_value                                                  (with_value)
              | pattern_match                                               (pattern_match)
              | LPAREN RPAREN                                               (A.SeqExp[])

structs_or_sigs
              : structure_nt structs_or_sigs                                (A.StructsSigsExp(structure_nt::valOf(extractStructSigList(structs_or_sigs))))
              | signature_nt structs_or_sigs                                (A.StructsSigsExp(signature_nt::valOf(extractStructSigList(structs_or_sigs))))
              | epsilon                                                     (A.StructsSigsExp([]))

structure_nt  : STRUCTURE ID EQ struct_body                                 (A.StructExp{name = Symbol.symbol(ID), signat = NONE, decs = struct_body, pos = STRUCTUREleft})
              | STRUCTURE ID COLON ID EQ struct_body                        (A.StructExp{name = Symbol.symbol(ID1), signat = SOME(A.NamedSigExp(Symbol.symbol(ID2)), ID2left), decs = struct_body, pos = STRUCTUREleft})
              | STRUCTURE ID COLON sig_body EQ struct_body                  (A.StructExp{name = Symbol.symbol(ID), signat = SOME(A.AnonSigExp(sig_body), sig_bodyleft), decs = struct_body, pos = STRUCTUREleft})

struct_body   : STRUCT decs END                                             (decs)

signature_nt  : SIGNATURE ID EQ sig_body                                    (A.SigExp{name = Symbol.symbol(ID), defs = sig_body})

sig_body      : SIG sigs END                                                (sigs)

sigs          : val_sig sigs                                                (val_sig::sigs)
              | ty_sig sigs                                                 (ty_sig::sigs)
              | module_sig sigs                                             (module_sig::sigs)
              | epsilon                                                     ([])

val_sig       : VAL ID COLON ty                                             (A.ValDef{name = Symbol.symbol(ID), ty = (ty, tyleft), pos = VALleft})

ty_sig        : TYPE ID                                                     (A.TypeDef{name = Symbol.symbol(ID), pos = TYPEleft})

module_sig    : MODULE ID COLON ty THIN_ARROW ty                            (A.ModuleDef{name = Symbol.symbol(ID), input_ty = ty1, output_ty = ty2, pos = MODULEleft})

array_access  : exp LBRACK exp RBRACK %prec ARRAY_ACC                       (A.ArrayAccExp{exp = exp1, index = exp2, pos = exp1left})

struct_access : ID DOT ID                                                   (A.StructAccExp{name = Symbol.symbol(ID1), field = Symbol.symbol(ID2), pos = ID1left})

tuple_access  : POUND INT exp %prec RECORD_ACC                              (A.RecordAccExp{exp = exp, field = Symbol.symbol(Int.toString(INT)), pos = POUNDleft})

record_access : POUND ID exp                                                (A.RecordAccExp{exp = exp, field = Symbol.symbol(ID), pos = POUNDleft})

deref         : BANG exp                                                    (A.DerefExp{exp = exp, pos = BANGleft})

access        : array_access                                                (array_access)
              | struct_access                                               (struct_access)
              | tuple_access                                                (tuple_access)
              | record_access                                               (record_access)
              | deref                                                       (deref)

operation     : int_op                                                      (int_op)
              | real_op                                                     (real_op)
              | bit_op                                                      (bit_op)
              | compare_op                                                  (compare_op)
              | list_op                                                     (list_op)

int_op        : UMINUS exp                                                  (A.UnOpExp{exp = exp1, oper = A.IntMinusOp, pos = UMINUSleft})
              | exp INT_PLUS exp                                            (A.BinOpExp{left = exp1, oper = A.IntPlusOp, right = exp2, pos = exp1left})
              | exp INT_MINUS exp                                           (A.BinOpExp{left = exp1, oper = A.IntMinusOp, right = exp2, pos = exp1left})
              | exp INT_TIMES exp                                           (A.BinOpExp{left = exp1, oper = A.IntTimesOp, right = exp2, pos = exp1left})
              | exp INT_DIVIDE exp                                          (A.BinOpExp{left = exp1, oper = A.IntDivideOp, right = exp2, pos = exp1left})
              | exp INT_MOD exp                                             (A.BinOpExp{left = exp1, oper = A.IntModOp, right = exp2, pos = exp1left})

real_op       : exp REAL_PLUS exp                                           (A.BinOpExp{left = exp1, oper = A.RealPlusOp, right = exp2, pos = exp1left})
              | exp REAL_MINUS exp                                          (A.BinOpExp{left = exp1, oper = A.RealMinusOp, right = exp2, pos = exp1left})
              | exp REAL_TIMES exp                                          (A.BinOpExp{left = exp1, oper = A.RealTimesOp, right = exp2, pos = exp1left})
              | exp REAL_DIVIDE exp                                         (A.BinOpExp{left = exp1, oper = A.RealDivideOp, right = exp2, pos = exp1left})

bit_op        : BIT_NOT exp                                                 (A.UnOpExp{exp = exp1, oper = A.BitNotOp, pos = BIT_NOTleft})
              | BIT_OR_REDUCE exp                                           (A.UnOpExp{exp = exp1, oper = A.BitOrReduceOp, pos = BIT_OR_REDUCEleft})
              | BIT_AND_REDUCE exp                                          (A.UnOpExp{exp = exp1, oper = A.BitAndReduceOp, pos = BIT_AND_REDUCEleft})
              | BIT_XOR_REDUCE exp                                          (A.UnOpExp{exp = exp1, oper = A.BitXorReduceOp, pos = BIT_XOR_REDUCEleft})
              | exp BIT_DOUBLE_OR exp                                       (A.BinOpExp{left = exp1, oper = A.BitDoubleOrOp, right = exp2, pos = exp1left})
              | exp BIT_DOUBLE_AND exp                                      (A.BinOpExp{left = exp1, oper = A.BitDoubleAndOp, right = exp2, pos = exp1left})
              | exp BIT_DOUBLE_XOR exp                                      (A.BinOpExp{left = exp1, oper = A.BitDoubleXorOp, right = exp2, pos = exp1left})
              | exp BIT_OR exp                                              (A.BinOpExp{left = exp1, oper = A.BitOrOp, right = exp2, pos = exp1left})
              | exp BIT_AND exp                                             (A.BinOpExp{left = exp1, oper = A.BitAndOp, right = exp2, pos = exp1left})
              | exp BIT_XOR exp                                             (A.BinOpExp{left = exp1, oper = A.BitXorOp, right = exp2, pos = exp1left})
              | exp BIT_SLL exp                                             (A.BinOpExp{left = exp1, oper = A.BitSLLOp, right = exp2, pos = exp1left})
              | exp BIT_SRL exp                                             (A.BinOpExp{left = exp1, oper = A.BitSRLOp, right = exp2, pos = exp1left})
              | exp BIT_SRA exp                                             (A.BinOpExp{left = exp1, oper = A.BitSRAOp, right = exp2, pos = exp1left})

compare_op    : exp EQ exp                                                  (A.BinOpExp{left = exp1, oper = A.EqOp, right = exp2, pos = exp1left})
              | exp NEQ exp                                                 (A.BinOpExp{left = exp1, oper = A.NeqOp, right = exp2, pos = exp1left})
              | exp GT exp                                                  (A.BinOpExp{left = exp1, oper = A.GtOp, right = exp2, pos = exp1left})
              | exp LT exp                                                  (A.BinOpExp{left = exp1, oper = A.LtOp, right = exp2, pos = exp1left})
              | exp GE exp                                                  (A.BinOpExp{left = exp1, oper = A.GeOp, right = exp2, pos = exp1left})
              | exp LE exp                                                  (A.BinOpExp{left = exp1, oper = A.LeOp, right = exp2, pos = exp1left})

list_op       : exp CONS exp                                                (A.BinOpExp{left = exp1, oper = A.ConsOp, right = exp2, pos = exp1left})

let_block     : LET decs IN exp END                                         (A.LetExp{decs = decs, body = exp1, pos = LETleft})

decs          : val_dec non_val_dec                                         (val_dec::non_val_dec)
              | fun_dec non_fun_dec                                         (fun_dec::non_fun_dec)
              | ty_dec non_ty_dec                                           (ty_dec::non_ty_dec)
              | sdataty_dec non_sdataty_dec                                 (sdataty_dec::non_sdataty_dec)
              | hdataty_dec non_hdataty_dec                                 (hdataty_dec::non_hdataty_dec)
              | module_dec non_module_dec                                   (module_dec::non_module_dec)
              | epsilon                                                     ([])

non_val_dec   : fun_dec non_fun_dec                                         (fun_dec::non_fun_dec)
              | ty_dec non_ty_dec                                           (ty_dec::non_ty_dec)
              | sdataty_dec non_sdataty_dec                                 (sdataty_dec::non_sdataty_dec)
              | hdataty_dec non_hdataty_dec                                 (hdataty_dec::non_hdataty_dec)
              | module_dec non_module_dec                                   (module_dec::non_module_dec)
              | epsilon                                                     ([])

non_fun_dec   : val_dec non_val_dec                                         (val_dec::non_val_dec)
              | ty_dec non_ty_dec                                           (ty_dec::non_ty_dec)
              | sdataty_dec non_sdataty_dec                                 (sdataty_dec::non_sdataty_dec)
              | hdataty_dec non_hdataty_dec                                 (hdataty_dec::non_hdataty_dec)
              | module_dec non_module_dec                                   (module_dec::non_module_dec)
              | epsilon                                                     ([])

non_ty_dec    : val_dec non_val_dec                                         (val_dec::non_val_dec)
              | fun_dec non_fun_dec                                         (fun_dec::non_fun_dec)
              | sdataty_dec non_sdataty_dec                                 (sdataty_dec::non_sdataty_dec)
              | hdataty_dec non_hdataty_dec                                 (hdataty_dec::non_hdataty_dec)
              | module_dec non_module_dec                                   (module_dec::non_module_dec)
              | epsilon                                                     ([])

non_sdataty_dec: val_dec non_val_dec                                        (val_dec::non_val_dec)
              | ty_dec non_ty_dec                                           (ty_dec::non_ty_dec)
              | fun_dec non_fun_dec                                         (fun_dec::non_fun_dec)
              | hdataty_dec non_hdataty_dec                                 (hdataty_dec::non_hdataty_dec)
              | module_dec non_module_dec                                   (module_dec::non_module_dec)
              | epsilon                                                     ([])

non_hdataty_dec: val_dec non_val_dec                                        (val_dec::non_val_dec)
              | ty_dec non_ty_dec                                           (ty_dec::non_ty_dec)
              | fun_dec non_fun_dec                                         (fun_dec::non_fun_dec)
              | sdataty_dec non_sdataty_dec                                 (sdataty_dec::non_sdataty_dec)
              | module_dec non_module_dec                                   (module_dec::non_module_dec)
              | epsilon                                                     ([])

non_module_dec: val_dec non_val_dec                                         (val_dec::non_val_dec)
              | fun_dec non_fun_dec                                         (fun_dec::non_fun_dec)
              | ty_dec non_ty_dec                                           (ty_dec::non_ty_dec)
              | sdataty_dec non_sdataty_dec                                 (sdataty_dec::non_sdataty_dec)
              | hdataty_dec non_hdataty_dec                                 (hdataty_dec::non_hdataty_dec)
              | epsilon                                                     ([])

val_dec       : VAL ID EQ exp                                               (A.ValDec[{name = Symbol.symbol(ID), escape = ref true, ty = (A.PlaceholderTy(ref ()), IDleft), init = exp1, pos = VALleft}])
              | VAL ID COLON ty EQ exp                                      (A.ValDec[{name = Symbol.symbol(ID), escape = ref true, ty = (ty, tyleft), init = exp1, pos = VALleft}])
              | VAL ID EQ exp val_dec                                       (A.ValDec({name = Symbol.symbol(ID), escape = ref true, ty = (A.PlaceholderTy(ref ()), IDleft), init = exp1, pos = VALleft}::valOf(extractValDecList(val_dec))))
              | VAL ID COLON ty EQ exp val_dec                              (A.ValDec({name = Symbol.symbol(ID), escape = ref true, ty = (ty, tyleft), init = exp1, pos = VALleft}::valOf(extractValDecList(val_dec))))

fun_dec       : fun_dec_no_type                                             (fun_dec_no_type)
              | fun_dec_with_type                                           (fun_dec_with_type)
              | fun_dec_no_type fun_dec                                     (A.FunctionDec(valOf(extractFunDecList(fun_dec_no_type)) @ valOf(extractFunDecList(fun_dec))))
              | fun_dec_with_type fun_dec                                   (A.FunctionDec(valOf(extractFunDecList(fun_dec_with_type)) @ valOf(extractFunDecList(fun_dec))))

fun_dec_no_type
              : FUN ID fun_params EQ exp                                    (A.FunctionDec[{name = Symbol.symbol(ID), params = fun_params1, result = (A.PlaceholderTy(ref()), IDleft), body = exp1, pos = FUNleft}])

fun_dec_with_type
              : FUN ID fun_params COLON ty EQ exp                           (A.FunctionDec[{name = Symbol.symbol(ID), params = fun_params1, result = (ty1, ty1left), body = exp1, pos = FUNleft}])

fun_params    : fun_params fun_param                                        (fun_params1 @ [fun_param1])
              | fun_param                                                   ([fun_param1])

fun_param     : ID                                                          (A.SingleParam{name = Symbol.symbol(ID), ty = A.PlaceholderTy(ref ()), escape = ref true, pos = IDleft})
              | LPAREN RPAREN                                               (param([], 0))
              | LPAREN opt_ty_fields RPAREN                                 (param(opt_ty_fields, 0))
              | LBRACE opt_ty_fields RBRACE                                 (param(opt_ty_fields, 1))

ty_dec        : TYPE tids ID EQ ty                                          (A.TypeDec[{name = Symbol.symbol(ID), ty = ty1, tyvars = SOME(tids), opdef = NONE, pos = TYPEleft}])
              | TYPE tids ID EQ ty ty_dec                                   (A.TypeDec([{name = Symbol.symbol(ID), ty = ty1, tyvars = SOME(tids), opdef = NONE, pos = TYPEleft}] @ valOf(extractTypeDecList(ty_dec))))
              | TYPE tids ID EQ ty with_type                                (A.TypeDec[{name = Symbol.symbol(ID), ty = ty1, tyvars = SOME(tids), opdef = SOME(with_type), pos = TYPEleft}])
              | TYPE tids ID EQ ty with_type ty_dec                         (A.TypeDec([{name = Symbol.symbol(ID), ty = ty1, tyvars = SOME(tids), opdef = SOME(with_type), pos = TYPEleft}] @ valOf(extractTypeDecList(ty_dec))))
              | TYPE ID EQ ty                                               (A.TypeDec[{name = Symbol.symbol(ID), ty = ty1, tyvars = NONE, opdef = NONE, pos = TYPEleft}])
              | TYPE ID EQ ty ty_dec                                        (A.TypeDec([{name = Symbol.symbol(ID), ty = ty1, tyvars = NONE, opdef = NONE, pos = TYPEleft}] @ valOf(extractTypeDecList(ty_dec))))
              | TYPE ID EQ ty with_type                                     (A.TypeDec[{name = Symbol.symbol(ID), ty = ty1, tyvars = NONE, opdef = SOME(with_type), pos = TYPEleft}])
              | TYPE ID EQ ty with_type ty_dec                              (A.TypeDec([{name = Symbol.symbol(ID), ty = ty1, tyvars = NONE, opdef = SOME(with_type), pos = TYPEleft}] @ valOf(extractTypeDecList(ty_dec))))

ty            : TID                                                         (A.TyVar(Symbol.symbol(TID), TIDleft))
              | typarams                                                    (typarams)
              | ID                                                          (A.NameTy(Symbol.symbol(ID), IDleft))
              | ty INT_TIMES ty                                             (sw_coalesce((ty1, ty1left), (ty2, ty2left)))
              | ty POUND_TIMES ty                                           (hw_coalesce((ty1, ty1left), (ty2, ty2left)))
              | LBRACE ty_fields RBRACE                                     (A.SWRecordTy(ty_fields, LBRACEleft))
              | POUND LBRACE ty_fields RBRACE                               (A.HWRecordTy(ty_fields, LBRACEleft))
              | ty AT exp                                                   (A.TemporalTy(ty1, exp1, ty1left))
              | ty LBRACK exp RBRACK                                        (A.ArrayTy(ty1, exp1, ty1left))
              | ty LIST                                                     (A.ListTy(ty1, ty1left))
              | ty REF                                                      (A.RefTy(ty1, ty1left))
              | ty SW                                                       (A.SWTy(ty1, ty1left))
              | ty THIN_ARROW ty                                            (A.FunTy(ty1, ty2, ty1left))
              | LPAREN ty RPAREN                                            (ty)

typarams      : ty ID                                                       (A.ParameterizedTy(Symbol.symbol(ID), [ty], tyleft))
              | LPAREN ty typarams_tail RPAREN ID                           (A.ParameterizedTy(Symbol.symbol(ID), ty::typarams_tail, LPARENleft))

typarams_tail : COMMA ty typarams_tail                                      (ty::typarams_tail)
              | epsilon                                                     ([])

tids          : TID                                                         ([Symbol.symbol(TID)])
              | LPAREN TID tids_tail RPAREN                                 (Symbol.symbol(TID)::tids_tail)

tids_tail     : COMMA TID tids_tail                                         (Symbol.symbol(TID)::tids_tail)
              | epsilon                                                     ([])

opt_ty_fields : opt_ty_field_tail                                           (opt_ty_field_tail)
              | epsilon                                                     ([])

opt_ty_field_tail:
                ID                                                          ([{name = Symbol.symbol(ID), ty = A.PlaceholderTy(ref ()), escape = ref true, pos = IDleft}])
              | ID COLON ty                                                 ([{name = Symbol.symbol(ID), ty = ty1, escape = ref true, pos = IDleft}])
              | opt_ty_field_tail COMMA ID                                  (opt_ty_field_tail @ [{name = Symbol.symbol(ID), ty = A.PlaceholderTy(ref ()), escape = ref true, pos = opt_ty_field_tailleft}])
              | opt_ty_field_tail COMMA ID COLON ty                         (opt_ty_field_tail @ [{name = Symbol.symbol(ID), ty = ty1, escape = ref true, pos = opt_ty_field_tailleft}])

ty_fields     : ty_field_tail                                               (ty_field_tail)
              | epsilon                                                     ([])

ty_field_tail : ID COLON ty                                                 ([{name = Symbol.symbol(ID), ty = ty1, escape = ref true, pos = IDleft}])
              | ty_field_tail COMMA ID COLON ty                             (ty_field_tail1 @ [{name = Symbol.symbol(ID), ty = ty1, escape = ref true, pos = ty_field_tail1left}])

with_type     : WITH OP EQ LPAREN ID COMMA ID RPAREN EQ exp with_type_tail  ([{oper = A.EqOp, param_a = Symbol.symbol(ID1), param_b = Symbol.symbol(ID2), body = exp1, pos = WITHleft}] @ with_type_tail1)
              | WITH OP NEQ LPAREN ID COMMA ID RPAREN EQ exp with_type_tail ([{oper = A.NeqOp, param_a = Symbol.symbol(ID1), param_b = Symbol.symbol(ID2), body = exp1, pos = WITHleft}] @ with_type_tail1)
              | WITH OP GT LPAREN ID COMMA ID RPAREN EQ exp with_type_tail  ([{oper = A.GtOp, param_a = Symbol.symbol(ID1), param_b = Symbol.symbol(ID2), body = exp1, pos = WITHleft}] @ with_type_tail1)
              | WITH OP LT LPAREN ID COMMA ID RPAREN EQ exp with_type_tail  ([{oper = A.LtOp, param_a = Symbol.symbol(ID1), param_b = Symbol.symbol(ID2), body = exp1, pos = WITHleft}] @ with_type_tail1)
              | WITH OP GE LPAREN ID COMMA ID RPAREN EQ exp with_type_tail  ([{oper = A.GeOp, param_a = Symbol.symbol(ID1), param_b = Symbol.symbol(ID2), body = exp1, pos = WITHleft}] @ with_type_tail1)
              | WITH OP LE LPAREN ID COMMA ID RPAREN EQ exp with_type_tail  ([{oper = A.LeOp, param_a = Symbol.symbol(ID1), param_b = Symbol.symbol(ID2), body = exp1, pos = WITHleft}] @ with_type_tail1)

with_type_tail: AND with_type                                               (with_type)
              | epsilon                                                     ([])

sdataty_dec   : SDATATYPE tids ID EQ ID dataty_tail                         (A.SWDatatypeDec([{name = Symbol.symbol(ID1), tyvars = SOME(tids), datacons = {datacon = Symbol.symbol(ID2), ty = A.NoTy, pos = ID2left}::dataty_tail}]))
              | SDATATYPE tids ID EQ ID dataty_tail sdataty_dec             (A.SWDatatypeDec({name = Symbol.symbol(ID1), tyvars = SOME(tids), datacons = {datacon = Symbol.symbol(ID2), ty = A.NoTy, pos = ID2left}::dataty_tail}::valOf(extractDatatypeDecList(sdataty_dec))))
              | SDATATYPE tids ID EQ ID OF ty dataty_tail                   (A.SWDatatypeDec([{name = Symbol.symbol(ID1), tyvars = SOME(tids), datacons = {datacon = Symbol.symbol(ID2), ty = ty, pos = ID2left}::dataty_tail}]))
              | SDATATYPE tids ID EQ ID OF ty dataty_tail sdataty_dec       (A.SWDatatypeDec({name = Symbol.symbol(ID1), tyvars = SOME(tids), datacons = {datacon = Symbol.symbol(ID2), ty = ty, pos = ID2left}::dataty_tail}::valOf(extractDatatypeDecList(sdataty_dec))))
              | SDATATYPE ID EQ ID dataty_tail                              (A.SWDatatypeDec([{name = Symbol.symbol(ID1), tyvars = NONE, datacons = {datacon = Symbol.symbol(ID2), ty = A.NoTy, pos = ID2left}::dataty_tail}]))
              | SDATATYPE ID EQ ID dataty_tail sdataty_dec                  (A.SWDatatypeDec({name = Symbol.symbol(ID1), tyvars = NONE, datacons = {datacon = Symbol.symbol(ID2), ty = A.NoTy, pos = ID2left}::dataty_tail}::valOf(extractDatatypeDecList(sdataty_dec))))
              | SDATATYPE ID EQ ID OF ty dataty_tail                        (A.SWDatatypeDec([{name = Symbol.symbol(ID1), tyvars = NONE, datacons = {datacon = Symbol.symbol(ID2), ty = ty, pos = ID2left}::dataty_tail}]))
              | SDATATYPE ID EQ ID OF ty dataty_tail sdataty_dec            (A.SWDatatypeDec({name = Symbol.symbol(ID1), tyvars = NONE, datacons = {datacon = Symbol.symbol(ID2), ty = ty, pos = ID2left}::dataty_tail}::valOf(extractDatatypeDecList(sdataty_dec))))

hdataty_dec   : HDATATYPE tids ID EQ ID dataty_tail                         (A.HWDatatypeDec([{name = Symbol.symbol(ID1), tyvars = SOME(tids), datacons = {datacon = Symbol.symbol(ID2), ty = A.NoTy, pos = ID2left}::dataty_tail}]))
              | HDATATYPE tids ID EQ ID dataty_tail hdataty_dec             (A.HWDatatypeDec({name = Symbol.symbol(ID1), tyvars = SOME(tids), datacons = {datacon = Symbol.symbol(ID2), ty = A.NoTy, pos = ID2left}::dataty_tail}::valOf(extractDatatypeDecList(hdataty_dec))))
              | HDATATYPE tids ID EQ ID OF ty dataty_tail                   (A.HWDatatypeDec([{name = Symbol.symbol(ID1), tyvars = SOME(tids), datacons = {datacon = Symbol.symbol(ID2), ty = ty, pos = ID2left}::dataty_tail}]))
              | HDATATYPE tids ID EQ ID OF ty dataty_tail hdataty_dec       (A.HWDatatypeDec({name = Symbol.symbol(ID1), tyvars = SOME(tids), datacons = {datacon = Symbol.symbol(ID2), ty = ty, pos = ID2left}::dataty_tail}::valOf(extractDatatypeDecList(hdataty_dec))))
              | HDATATYPE ID EQ ID dataty_tail                              (A.HWDatatypeDec([{name = Symbol.symbol(ID1), tyvars = NONE, datacons = {datacon = Symbol.symbol(ID2), ty = A.NoTy, pos = ID2left}::dataty_tail}]))
              | HDATATYPE ID EQ ID dataty_tail hdataty_dec                  (A.HWDatatypeDec({name = Symbol.symbol(ID1), tyvars = NONE, datacons = {datacon = Symbol.symbol(ID2), ty = A.NoTy, pos = ID2left}::dataty_tail}::valOf(extractDatatypeDecList(hdataty_dec))))
              | HDATATYPE ID EQ ID OF ty dataty_tail                        (A.HWDatatypeDec([{name = Symbol.symbol(ID1), tyvars = NONE, datacons = {datacon = Symbol.symbol(ID2), ty = ty, pos = ID2left}::dataty_tail}]))
              | HDATATYPE ID EQ ID OF ty dataty_tail hdataty_dec            (A.HWDatatypeDec({name = Symbol.symbol(ID1), tyvars = NONE, datacons = {datacon = Symbol.symbol(ID2), ty = ty, pos = ID2left}::dataty_tail}::valOf(extractDatatypeDecList(hdataty_dec))))

dataty_tail   : PIPE_EQUALS ID OF ty dataty_tail                            ({datacon = Symbol.symbol(ID), ty = ty, pos = IDleft}::dataty_tail)
              | PIPE_EQUALS ID dataty_tail                                  ({datacon = Symbol.symbol(ID), ty = A.NoTy, pos = IDleft}::dataty_tail)
              | epsilon                                                     ([])

module_dec    : module_dec_no_type                                          (A.ModuleDec([module_dec_no_type]))
              | module_dec_with_type                                        (A.ModuleDec([module_dec_with_type]))
              | module_dec_no_type module_dec                               (A.ModuleDec(module_dec_no_type::valOf(extractModDecList(module_dec))))
              | module_dec_with_type module_dec                             (A.ModuleDec(module_dec_with_type::valOf(extractModDecList(module_dec))))

module_dec_no_type
              : MODULE ID fun_param EQ exp                                  ({name = Symbol.symbol(ID), arg = fun_param, result = (A.PlaceholderTy(ref ()), IDleft), body = exp, pos = MODULEleft})

module_dec_with_type
              : MODULE ID fun_param COLON ty EQ exp                         ({name = Symbol.symbol(ID), arg = fun_param, result = (ty, tyleft), body = exp, pos = MODULEleft})

semicolon_exp0: SEMICOLON exp semicolon_exp0                                ([(exp1, exp1left)] @ semicolon_exp0)
              | epsilon                                                     ([])

exp_seq       : LPAREN exp RPAREN                                           (exp)
              | LPAREN exp SEMICOLON exp semicolon_exp0 RPAREN              (A.SeqExp([(exp1, exp1left)] @ [(exp2, exp2left)] @ semicolon_exp0))

assign        : exp ASSIGN exp                                              (A.AssignExp{lhs = exp1, rhs = exp2, pos = exp1left})

exp_comma_tail: COMMA exp exp_comma_tail                                    ([(exp1, exp1left)] @ exp_comma_tail)
              | epsilon                                                     ([])

conditional   : IF exp THEN exp ELSE exp                                    (A.IfExp{test = exp1, then' = exp2, else' = SOME(exp3), pos = IFleft})
              | IF exp THEN exp                                             (A.IfExp{test = exp1, then' = exp2, else' = NONE, pos = IFleft})
              | exp ANDALSO exp                                             (A.IfExp{test = exp1, then' = exp2, else' = SOME(A.IntExp(0, 0)), pos = exp1left})
              | exp ORELSE exp                                              (A.IfExp{test = exp1, then' = A.IntExp(1, 0), else' = SOME(exp2), pos = exp1left})

insts         : sw_rec_inst                                                 (sw_rec_inst)
              | hw_rec_inst                                                 (hw_rec_inst)
              | ref_inst                                                    (ref_inst)
              | array_inst                                                  (array_inst)
              | list_inst                                                   (list_inst)
              | sw_tuple_inst                                               (sw_tuple_inst)
              | hw_tuple_inst                                               (hw_tuple_inst)
              | sw_inst                                                     (sw_inst)

sw_rec_inst   : LBRACE rec_inst_body RBRACE                                 (A.SWRecordExp{fields = rec_inst_body, pos = LBRACEleft})

hw_rec_inst   : POUND LBRACE rec_inst_body RBRACE                           (A.HWRecordExp{fields = rec_inst_body, pos = POUNDleft})

rec_inst_body : ID EQ exp rec_field_comma_tail                              ([(Symbol.symbol(ID), exp, IDleft)] @ rec_field_comma_tail)
              | epsilon                                                     ([])

rec_field_comma_tail
              : COMMA ID EQ exp rec_field_comma_tail                        ([(Symbol.symbol(ID), exp, IDleft)] @ rec_field_comma_tail)
              | epsilon                                                     ([])

ref_inst      : REF exp                                                     (A.RefExp(exp, REFleft))

array_inst    : POUND LBRACK list_elements RBRACK                           (A.ArrayExp(Vector.fromList(list_elements)))
              | POUND LBRACK exp SEMICOLON exp RBRACK                       (A.BitArrayExp{size = exp1, result = exp2, spec = NONE})
              | bit_array_inst                                              (bit_array_inst)

list_inst     : LBRACK list_elements RBRACK                                 (A.ListExp(list_elements))
              | NIL                                                         (A.ListExp([]))

list_elements : exp exp_comma_tail                                          ([(exp1, exp1left)] @ exp_comma_tail)
              | epsilon                                                     ([])

sw_tuple_inst : LPAREN list_elements RPAREN                                 (A.SWRecordExp{fields = numberedExpFields(list_elements), pos = LPARENleft})

hw_tuple_inst : POUND LPAREN list_elements RPAREN                           (A.HWRecordExp{fields = numberedExpFields(list_elements), pos = LPARENleft})

sw_inst       : SW exp                                                      (A.SWExp(exp, SWleft))

bit_array_inst: exp TID COLON exp %prec BIT_ARRAY_INST                      (A.BitArrayExp{size = exp1, result = exp2, spec = SOME(TID)})

with_value    : exp WITH sw_rec_inst                                        (A.WithExp{exp = exp, fields = valOf(extractSWFields(sw_rec_inst)), pos = expleft})

pattern_match : CASE exp OF pattern FAT_ARROW exp matches_tail %prec MATCH  (A.PatternMatchExp{exp = exp1, cases = ([{match = pattern1, result = exp2, pos = pattern1left}] @ matches_tail), pos = CASEleft})

matches_tail  : matches_tail PIPE_EQUALS pattern FAT_ARROW exp %prec MATCH_TAIL
                                                                            (matches_tail @ [{match = pattern1, result = exp1, pos = pattern1left}])
              | epsilon                                                     ([])

pattern       : INT                                                         (A.IntExp(INT, INTleft))
              | STRING                                                      (A.StringExp(STRING, STRINGleft))
              | REAL                                                        (A.RealExp(REAL, REALleft))
              | BIT                                                         (A.BitExp(BIT, BITleft))
              | ID                                                          (A.VarExp(Symbol.symbol(ID), IDleft))
              | ID pattern                                                  (A.ApplyExp(A.VarExp(Symbol.symbol(ID), IDleft), pattern, IDleft))
              | LPAREN opt_patterns RPAREN                                  (A.SWRecordExp{fields = numberedExpFields(opt_patterns), pos = LPARENleft})
              | POUND LPAREN opt_patterns RPAREN                            (A.HWRecordExp{fields = numberedExpFields(opt_patterns), pos = POUNDleft})
              | LBRACK opt_patterns RBRACK                                  (A.ListExp(opt_patterns))
              | POUND LBRACK opt_patterns RBRACK                            (A.ArrayExp(Vector.fromList(opt_patterns)))
              | LBRACE rec_patterns RBRACE                                  (A.SWRecordExp{fields = rec_patterns, pos = LBRACEleft})
              | POUND LBRACE rec_patterns RBRACE                            (A.HWRecordExp{fields = rec_patterns, pos = POUNDleft})

opt_patterns  : pattern opt_patterns_tail                                   ([(pattern, patternleft)] @ opt_patterns_tail)
              | epsilon                                                     ([])

opt_patterns_tail
              : COMMA pattern opt_patterns_tail                             ([(pattern, patternleft)] @ opt_patterns_tail)
              | epsilon                                                     ([])

rec_patterns  : ID EQ pattern rec_patterns_tail                             ([(Symbol.symbol(ID), pattern, patternleft)] @ rec_patterns_tail)

rec_patterns_tail
              : COMMA ID EQ pattern rec_patterns_tail                       ([(Symbol.symbol(ID), pattern, patternleft)] @ rec_patterns_tail)
              | epsilon                                                     ([])

epsilon       : %prec EPSILON                                               ()
