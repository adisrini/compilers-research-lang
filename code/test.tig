let

	fun testArith x y = ((x + y)/(x - y))*((x - y)/(x % y))

	fun testCons a r = a::r

	fun testEqual s t = (s = t)

	fun testNotEqual b c = (b <> c)

	fun testInequality a b = a > (b + 1)

	fun testIfElse x y z = if x > y then y else z

	(* fun testIf x y = if x > (y + 1) then y (* should error *) *)

	fun testAssign (m : int ref) n = (m := n)

	fun testRef (r : int ref ref, x) = (r := ref x)

	fun testDeref x y = (y := $x)

	fun testFunParams1 () = 0

	fun testFunParams2 a = a

	fun testFunParams3 (x, y, z) = x + y

	fun testFunParams4 {x, y, z} = x + y

	fun testSeq (a) (b, c) = (a + b; c = a)

	fun polyTest x =
	   let fun f y = y x   (* f: Poly['c] ('a->'c)->'c' *)
		     val z = x+2		(* substitute int for 'a in the poly *)
				 val a = f g (* if g is some int -> string fn, don't substitute string globally in the poly in venv, instead just unpoly *)
		 in
		     (f,z)
		 end
	(* f: 'a -> 'b -> real *)
	(* g: int -> 'b *)
	(* h: string -> 'a *)
	fun testApply(f, g, h) : real = f (g 0) (h "")

	fun adder a b = a + b
	val x = adder 0 1

	(*
	fun f x = x
	(* at this stage, should add POLY to venv instead of ARROW *)
	val y = 0
	(* at this stage, should UNPOLY *)
	val x = f y (* should say x is type int! make sure unpolying *)
	*)

in
	()
end


pattern: literal
			 | id
			 | datatypecon pattern
			 | (pattern, (, pattern)) (* optional pattern *)
			 | [pattern (, pattern)] (* optional pattern *)
			 | {pattern}
